<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Hexo博客主页分页问题</title>
    <url>/post/c075794d.html</url>
    <content><![CDATA[<p>今天看了一下自己的博客发现连续二十篇文章都没有分页. 看了下配置文件, 发现是在站点配置文件(就是博客根目录下的config.yml文件)下, per_page的选项, 更改后面的数字即可. <font color="red">注意冒号后面的空格</font></p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">index_generator:</span><br><span class="line">  path: ''</span><br><span class="line">  per_page: 10</span><br><span class="line">  order_by: -date</span><br></pre></td></tr></tbody></table></figure>

<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
  </entry>
  <entry>
    <title>Linux常用命令</title>
    <url>/post/d0edc1ed.html</url>
    <content><![CDATA[<h1 id="Linux常用指令"><a href="#Linux常用指令" class="headerlink" title="Linux常用指令"></a>Linux常用指令</h1><h2 id="export"><a href="#export" class="headerlink" title="export"></a>export</h2><blockquote>
<p>常用来<font color="red">临时</font>修改、新增、删除环境变量。<br><br>语法:<br><a id="more"></a></p>
</blockquote>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">export [变量名称]=[变量设置值]</span><br></pre></td></tr></tbody></table></figure>
<h2 id="pwd"><a href="#pwd" class="headerlink" title="pwd"></a>pwd</h2><blockquote>
<p>显示当前工作目录</p>
</blockquote>
<h2 id="cd"><a href="#cd" class="headerlink" title="cd"></a>cd</h2><blockquote>
<p>切换目录<br>语法:<br></p>
</blockquote>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">cd [目录名]</span><br></pre></td></tr></tbody></table></figure>

<blockquote>
<p>切换到上级目录:  <code>cd ..</code><br><br>切换到根目录:   <code>cd \</code></p>
</blockquote>
<h2 id="ls"><a href="#ls" class="headerlink" title="ls"></a>ls</h2><blockquote>
<p>用于显示目录内容，它的使用权限是所有用户。<br>语法:<br></p>
</blockquote>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">ls [options] 文件名</span><br></pre></td></tr></tbody></table></figure>
<h3 id="ls-F"><a href="#ls-F" class="headerlink" title="ls -F"></a>ls -F</h3><blockquote>
<p>在每一个文件的末尾加上一个字符说明该文件的类型，例如：<br></p>
</blockquote>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">/&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;表示目录&lt;br&gt;</span><br><span class="line">*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;表示可执行文件&lt;br&gt;</span><br><span class="line">@&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;表示符号链接&lt;br&gt;</span><br><span class="line">|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;表示管道文件&lt;br&gt;</span><br><span class="line">=&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;表示socket文件&lt;br&gt;</span><br></pre></td></tr></tbody></table></figure>
<h3 id="ls-a-ls-–all"><a href="#ls-a-ls-–all" class="headerlink" title="ls-a(== ls –all)"></a>ls-a(== ls –all)</h3><blockquote>
<p>列出所有的文件，包括以’ . ’开头的隐藏文件<br><br>刚刚测试了一下, 所有目录的文件中都有<code>. (当前目录)</code>以及<code>..(父目录)</code>,以便随时进行目录的返回</p>
</blockquote>
<h3 id="ls-l与ls-lh"><a href="#ls-l与ls-lh" class="headerlink" title="ls-l与ls -lh"></a>ls-l与ls -lh</h3><blockquote>
<p>列出文件的详细信息，如创建者、创建时间、文件的读写权限等。<br><br>与ls -l不同的是<code>ls -lh</code>现实的文件大小是转化唯有单位的易读的数据, 而<code>ls -l</code>则直接显示字节数.<br>而ls -l得到的结果如下<br><img src="https://i.imgur.com/reARS6E.png" alt=""><br>上图中, 第一组数的第一位标识文件类型. 后九位(xwr-组成)分三组, 每组三位分别表示<code>文件所有者</code>, <code>所有者所在的组</code>以及<code>其他用户</code>对该文件的权限. (可读, 可写, 可执行)<br><br>如果不同字母表示权限, 还可以用0~7的数字标识每组的权限.<br><br>这样的话, 777 就对应于rwx, 000 对应于—.<br><br>这点后面命令要用到.</p>
</blockquote>
<h3 id="ls-t"><a href="#ls-t" class="headerlink" title="ls-t"></a>ls-t</h3><blockquote>
<p>按时间进行文件的排序</p>
</blockquote>
<h3 id="ls-R"><a href="#ls-R" class="headerlink" title="ls-R"></a>ls-R</h3><blockquote>
<p>递归地列出所有的子目录及子目录中的文件。 </p>
</blockquote>
<h3 id="ls-S"><a href="#ls-S" class="headerlink" title="ls-S"></a>ls-S</h3><blockquote>
<p>以文件的大小进行降序排序</p>
</blockquote>
<h2 id="rm-或rmdir"><a href="#rm-或rmdir" class="headerlink" title="rm(或rmdir)"></a>rm(或rmdir)</h2><blockquote>
<p>语法</p>
<figure class="highlight plain"><figcaption><span>[options] [file name]```</span></figcaption><table><tbody><tr><td class="code"><pre><span class="line">### rm -r</span><br><span class="line">&gt;递归删除文件夹</span><br><span class="line">### rm -rf</span><br><span class="line">&gt;强制删除</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">## 切换root/切换用户</span><br><span class="line">&gt;方法一:&nbsp;``` su root </span><br></pre></td></tr></tbody></table></figure>
<p>这样的话需要输入root密码, 很多人并没有设置过. 因为linux在安装时会自动生成一个默认密码.所以在使用前需要先重新设定密码:<br>执行<code>sudo passwd</code>,输入两次密码,enter就可以了.<br>方法二:<code>sudo -i</code><br>这时候可能要你输入密码, 只要输入你当前用户的登录密码就好了.<br></p>
</blockquote>
<blockquote>
<p>异同: 相同之处很明显, 都可以以管理员身份操作.<br>而不同之处在于su仅仅取得root权限, 工作环境不变，而sudo是取得root的权限后进入root工作环境. 这个从英文命名上理解比较好</p>
</blockquote>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">su</span><br><span class="line">switch user</span><br></pre></td></tr></tbody></table></figure>
<p>而sudo则是</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">sudo</span><br><span class="line">super-user-do</span><br></pre></td></tr></tbody></table></figure>

<h2 id="chmod-change-mode"><a href="#chmod-change-mode" class="headerlink" title="chmod (change-mode)"></a>chmod (change-mode)</h2><blockquote>
<p>语法:</p>
</blockquote>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">chmod [options] [权限数值] [文件名]</span><br></pre></td></tr></tbody></table></figure>
<blockquote>
<p>options当然可有可无.<br><br>还可以<code>mkdir -m [权限数值] [file name]</code><br>这里说一下, 系统默认新建文件夹的权限是775, 新建文件的权限是664</p>
</blockquote>
<blockquote>
<p>chmod 的操作是只针对所描述的对象的.<br>例如: 之前 a.txt的属性是777<br>chmod o=x a.txt后, 它的权限是771</p>
</blockquote>
<h2 id="chown-change-owner"><a href="#chown-change-owner" class="headerlink" title="chown(change-owner)"></a>chown(change-owner)</h2><p>更改用户群组</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">chown owner::group filelist</span><br></pre></td></tr></tbody></table></figure>

<h2 id="sudo"><a href="#sudo" class="headerlink" title="sudo"></a>sudo</h2><p>增加sudoer,</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">sudo adduser username sudo</span><br><span class="line">``` </span><br><span class="line">删除</span><br></pre></td></tr></tbody></table></figure>
<p>sudo userdel username sudo</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line"></span><br><span class="line">## usermod(user-modify)</span><br><span class="line">设置用户相关</span><br><span class="line">更改用户shell的时候可用usermod -s, 前提是你当前用户有root权限</span><br><span class="line"></span><br><span class="line">## mv</span><br><span class="line">两个功能:</span><br><span class="line">1.重命名</span><br><span class="line">```mv [filename] [newname]</span><br></pre></td></tr></tbody></table></figure>
<p>2.移动文件</p>
<figure class="highlight plain"><figcaption><span>[file name] [new path]```</span></figcaption><table><tbody><tr><td class="code"><pre><span class="line">在使用其移动功能时, 注意../的使用</span><br><span class="line"></span><br><span class="line">## cp</span><br><span class="line">复制文件</span><br></pre></td></tr></tbody></table></figure>
<p>cp [file name] [new path]</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line"></span><br><span class="line">如果要将一个子目录copy到另一个目录下时, 需要加上 -r 选项;&lt;br&gt;</span><br><span class="line">使用cp命令时, 如不特殊指定, 那么文件的更改时间是最新一次的改动时间, 而文件夹则不会改变</span><br><span class="line">&gt;这里关于```cp -r```举个栗子,  pic1所描述的系统是文件``` /dir1/dir2```, ```/dir1/test.txt```, 以及```/dir3```. </span><br><span class="line">&gt;![pic1](https://i.imgur.com/Q1tddNr.png)</span><br><span class="line">&gt;此时如果执行```cp /dir1/* /dir2```的话,只有```test.txt``` copy到了dir3</span><br><span class="line">&gt;![](https://i.imgur.com/lKnOwuV.png)</span><br><span class="line">&gt;而```cp -r /dir1/* /dir2```则会将dir1&lt;font color= red&gt;中&lt;/font&gt;的内容全都copy.</span><br><span class="line">&gt;而```cp /dir1 /dir2```则会直接提示操作失败, 因为这里cp的对象是整个/dir1文件夹. 而之前的cp操作对象是/dir1&lt;font color=red&gt;下&lt;/font&gt;的所有文件及目录, 所以即使不加 -r 也可以把非目录文件copy到对应目录下.</span><br><span class="line">&gt; </span><br><span class="line">&gt;Over~&lt;br&gt;</span><br><span class="line">&gt;</span><br><span class="line">## grep</span><br><span class="line">在指定文件中搜索特定的内容，并将含有这些内容的行输出.</span><br></pre></td></tr></tbody></table></figure>
<p>grep [options] [关键字] [搜索目标]</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">&lt;font color=red&gt;**tips:**&lt;/font&gt;这里的搜索目标应该是普通文本.</span><br><span class="line"></span><br><span class="line">### grep -n</span><br><span class="line">显示搜索的关键字在文本中对应的行数</span><br><span class="line"></span><br><span class="line">### grep -v</span><br><span class="line">显示文本所有内容,除了[关键字]</span><br><span class="line"></span><br><span class="line">### grep -c</span><br><span class="line">显示关键字出现的次数</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">## find(默认递归)</span><br><span class="line">查找文件</span><br></pre></td></tr></tbody></table></figure>
<p>find [path] [options] [file name]</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line"></span><br><span class="line">### find [path] -name</span><br><span class="line">后接指定的文件名，支持通配符</span><br><span class="line"></span><br><span class="line">### find [path] -user</span><br><span class="line">后接所要查找的文件的归属者（用户）</span><br><span class="line"></span><br><span class="line">### find [path] -size </span><br><span class="line">后接文件大小, 形如&lt;br&gt;</span><br><span class="line">```find . -size +4k```就是在当前路径下递归查找大于4k的文件</span><br><span class="line"></span><br><span class="line">### sed</span><br><span class="line">编辑文本, 显示指定行数的内容</span><br></pre></td></tr></tbody></table></figure>
<p>sed -n ‘x,yp’ filename<br>//用以显示x,y行的内容</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line"></span><br><span class="line">## 内存</span><br><span class="line"></span><br><span class="line">```free -m``` 查看内存</span><br><span class="line"></span><br><span class="line">```fdisk -l ``` 查看系统物理内存&lt;br&gt; </span><br><span class="line">查看硬盘和分区的详细信息（需要root或超级用户的权限）  </span><br><span class="line">            </span><br><span class="line">```df -h``` 查看磁盘分区的总容量、已用容量等信息</span><br><span class="line"></span><br><span class="line">```du -sh``` 查看磁盘文件已用容量，以指定目录下的子目录为单位，显示每个子目录内所有档案所占用的磁盘空间大小。</span><br><span class="line"></span><br><span class="line">```lsblk``` 查看硬盘和分区分布</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">## head &amp; tail</span><br><span class="line">```head(tail) -**n** filelist</span><br></pre></td></tr></tbody></table></figure>
<p>查看一个或多个文件的首(末)n行</p>
<h2 id="ps-process-status"><a href="#ps-process-status" class="headerlink" title="ps(process-status)"></a>ps(process-status)</h2><p>查看执行ps命令的那个时刻的那些进程．</p>
<p>如果想要动态的显示进程信息，就可以使用top命令。</p>
<p>ps -l查看详细信息<br><img src="./blog_pic/Linux_cmd/ps-l2.png" alt="执行ps -l的类似效果图"><br><img src="./blog_pic/Linux_cmd/ps-l.png" alt="各字段的含义"><br>S的标识符 | 含义<br>— | —<br>D  | 不可中断<br>R(Runable) | 正在运行<br>S(Sleeping) | 正在休眠<br>T(trance) | 停止<br>Z(Zombie) | 僵尸进程</p>
<h2 id="文件压缩"><a href="#文件压缩" class="headerlink" title="文件压缩"></a>文件压缩</h2><table>
<thead>
<tr>
<th>压缩</th>
<th>解压</th>
</tr>
</thead>
<tbody><tr>
<td>gzip</td>
<td>gzip -d 或gunzip</td>
</tr>
<tr>
<td>bzip2</td>
<td>bzip2 -d</td>
</tr>
<tr>
<td>tar -zcvf</td>
<td>tar -zxvf (.gz)</td>
</tr>
<tr>
<td>tar -jcvf</td>
<td>tar -jxvf (.bz2)</td>
</tr>
<tr>
<td>tar -c</td>
<td>tar -x</td>
</tr>
<tr>
<td>-k可以保留原文件压缩</td>
<td></td>
</tr>
<tr>
<td>- 解压后的文件最后更改日期是和原文件相同的, 和解压时间无关</td>
<td></td>
</tr>
<tr>
<td>- tar解压后原文件存在</td>
<td></td>
</tr>
</tbody></table>
<h1 id="vim小tips"><a href="#vim小tips" class="headerlink" title="vim小tips"></a>vim小tips</h1><ul>
<li>x 也是剪切，使用后p命令可以粘贴出最近一次删除的内容。<br>目前接触到的x，d命令都是剪切，好像没有直接删除的，猜想删除就是在剪切的基础上实现的（类似于cp和mv的关系）；</li>
</ul>
<ul>
<li>除:wq外，ZZ也可以实现保存并退出的功能。（具体区目前别没有查到）；</li>
</ul>
<ul>
<li>:w是当前路径保存，后面还可以加上新路径， 实现“另存为”的功能；</li>
</ul>
<ul>
<li>vim 可以连续打开多个文件：vim file1 file2，然后使用命令:bn和:bp进行切换。或者vim打开后，使用:open filename来打开另一个文件；</li>
</ul>
<ul>
<li>移动光标时，<br>G按行移动：nG是到n行，G到末行，gg到首行；<br>w按单词移动（以空格为区分）：w到达下一个词首，e到达下个词尾；</li>
</ul>
<ul>
<li>%进行括号匹配（当前光标必须在括号的一端上，否则无意义）；</li>
</ul>
<ul>
<li>*和#，快速匹配全文中当前光标所在的单词，n是下一个,N上一个（对，类似于/pattern查找）；</li>
</ul>
<ul>
<li>/key\c不区分大小写，key、KeY都可以被匹配<br>/key\C区分大小写；</li>
</ul>
<ul>
<li><p>:s（substitute）命令用来查找和替换字符串。</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">:[range] s/before/after/tag</span><br></pre></td></tr></tbody></table></figure>
<p>ranges填写查找范围．1,7 s/mian/main/g就是把mian替换为．</p>
</li>
<li><p>: set nu可产生编号</p>
</li>
</ul>
<h1 id="更改shell"><a href="#更改shell" class="headerlink" title="更改shell"></a>更改shell</h1><figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">sudo vi /etc/passwd</span><br><span class="line">或</span><br><span class="line">sudo usermod -s /bin/bash</span><br></pre></td></tr></tbody></table></figure>

<h1 id="增删su角色"><a href="#增删su角色" class="headerlink" title="增删su角色"></a>增删su角色</h1><p>增:</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">sudo adduser username sudo</span><br><span class="line">``` </span><br><span class="line">删:</span><br></pre></td></tr></tbody></table></figure>
<p>sudo deluser username sudo</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line"></span><br><span class="line"># 增加用户</span><br></pre></td></tr></tbody></table></figure>
<p>supo useradd [-g group] newuser  -m<br>或<br>adduser</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">-g 组</span><br><span class="line"></span><br><span class="line">-m /home下生成newuser的家目录~</span><br><span class="line"># xdg-open</span><br><span class="line"> 以默认方式打开文件</span><br><span class="line"># swp 文件</span><br><span class="line">&gt;刚刚执行 ls -a 看到的, 网上查了一下, 就大概说一下&lt;br&gt;</span><br><span class="line">这个是在使用vim编辑文本然后非正常退出后产生的备份文件. 严格地说是在你一打开vim, 这额文件就产生了, 如果你正常退出, 它是不会保存的.&lt;br&gt;</span><br><span class="line">所以这个文件算是vim比较人性化的地方吧.</span><br><span class="line">具体恢复方法如下</span><br><span class="line">```vi -r [file name]</span><br></pre></td></tr></tbody></table></figure>
<h1 id="一些小知识"><a href="#一些小知识" class="headerlink" title="一些小知识"></a>一些小知识</h1><ul>
<li><p>usr是Unix System Resource的简称, <font color="red">不是什么user</font></p>
</li>
<li><p>linux用户目录一般在 /home/下</p>
</li>
<li><p>R一般表示递归(目录下所有文件及子目录)   recursion</p>
</li>
<li><p>r一般表示逆序   reverse</p>
</li>
<li><p>ls -ld显示自身信息<br>ls -l(long)<br><br>ls -rt(r= reverse t = time)</p>
</li>
</ul>
<blockquote>
<p><font color="red," size="15"> 注意各种命令配合管道操作</font></p>
</blockquote>
<h1 id="有点想不通"><a href="#有点想不通" class="headerlink" title="有点想不通"></a>有点想不通</h1><p>mv * ../.<br>为is和没那么是移动到上一目录<br><br>明白了 ../代表的是父目录, 而../.就代表父目录里. 没什么好疑问的</p>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>VirtualBox常见问题</title>
    <url>/post/77ec75ad.html</url>
    <content><![CDATA[<h1 id="不能分配USB设备xxx到虚拟电脑xxx"><a href="#不能分配USB设备xxx到虚拟电脑xxx" class="headerlink" title="不能分配USB设备xxx到虚拟电脑xxx:"></a>不能分配USB设备xxx到虚拟电脑xxx:</h1><p>1.进入<a href="https://www.virtualbox.org/wiki/Downloads" target="_blank" rel="noopener">vBox官网</a>, 按下图提示找到VirtualBox 6.1.2 Oracle VM VirtualBox Extension Pack一栏,然后点击All supported platforms下载, 下载之前请确保vbox是最新版本, 否则可能出现不适配的问题.<a id="more"></a><br><img src="https://i.imgur.com/URFX7UH.png" alt=""><br><br>2.下载好后, 双击便可以进行自动安装.<br><br>3.进到vBox软件中, 点击 设置-USB设置,<br>点击右边第二个新建筛选器, 选择自己的u盘<br><img src="https://i.imgur.com/eZ3qyMP.jpg" alt=""><br>4.进入虚拟机系统, </p>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
  </entry>
  <entry>
    <title>Linux中inode的含义及理解</title>
    <url>/post/79549cdf.html</url>
    <content><![CDATA[<blockquote><p>理解inode，要从文件储存说起。</p>
<p>文件储存在硬盘上，硬盘的最小存储单位叫做”扇区”（Sector）。每个扇区储存512字节（相当于0.5KB）。</p>
<p>操作系统读取硬盘的时候，不会一个个扇区地读取，这样效率太低，而是一次性连续读取多个扇区，即一次性读取一个”块”（block）。这种由多个扇区组成的”块”，是文件存取的最小单位。”块”的大小，最常见的是4KB，即连续八个 sector组成一个 block。</p>
<footer><strong>《理解inode》</strong><cite>阮一峰</cite></footer></blockquote><a id="more"></a>



<p>不知道是巧合还是规定，一个空文件夹的占用内存刚好是4KB<br><br>基本上就可以把inode理解为文件索引, inode里记载了所有除了文件内容和文件名以外地信息（例如文件所在块的位置，文件大小，文件改动时间等），这些inode都是由系统自己分配好的．在我们以文件名进行操作时，系统会找到文件名对应的inode，然后找到inode里的信息，到对应的块中去找到文件，然后进行操作．inode其实才是文件的＂真名＂，但不便于我们使用，所以才有我们自定义的文件名．<br>顺带一提，使用ｌｓ　－ｌ命令时，首行出现的ｔｏｔａｌ　ｘｘ，ｘｘ这个数值就是你所浏览的全部内容的每一个文件占用的块数（就是有多少个4096KB，不足4096也算一个）的和乘以４．</p>
<p>参考信息:<br><a href="http://www.ruanyifeng.com/blog/2011/12/inode.html" target="_blank" rel="noopener">http://www.ruanyifeng.com/blog/2011/12/inode.html</a><br><br><a href="https://www.cnblogs.com/Harley-Quinn/p/6591450.html" target="_blank" rel="noopener">https://www.cnblogs.com/Harley-Quinn/p/6591450.html</a></p>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Web 初学(1)</title>
    <url>/post/e67612e4.html</url>
    <content><![CDATA[<table>
<thead>
<tr>
<th>语言</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>html</td>
<td>structure</td>
</tr>
<tr>
<td>css</td>
<td>presentation</td>
</tr>
<tr>
<td>js</td>
<td>behavior</td>
</tr>
</tbody></table>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
  </entry>
  <entry>
    <title>Linux 入门命令</title>
    <url>/post/f69fadb0.html</url>
    <content><![CDATA[<h1 id="Linux常用指令"><a href="#Linux常用指令" class="headerlink" title="Linux常用指令"></a>Linux常用指令</h1><h2 id="export"><a href="#export" class="headerlink" title="export"></a>export</h2><blockquote>
<p>常用来<font color="red">临时</font>修改、新增、删除环境变量。<br><br>语法:<br><a id="more"></a></p>
</blockquote>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">export [变量名称]=[变量设置值]</span><br></pre></td></tr></tbody></table></figure>
<h2 id="pwd-print-work-directory"><a href="#pwd-print-work-directory" class="headerlink" title="pwd(print work directory)"></a>pwd(print work directory)</h2><blockquote>
<p>显示当前工作目录</p>
</blockquote>
<h2 id="cd-change-directory"><a href="#cd-change-directory" class="headerlink" title="cd(change directory)"></a>cd(change directory)</h2><blockquote>
<p>切换目录<br>语法:<br></p>
</blockquote>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">cd [目录名]</span><br></pre></td></tr></tbody></table></figure>

<blockquote>
<p>切换到上级目录:  <code>cd ..</code><br><br>切换到根目录:   <code>cd \</code></p>
</blockquote>
<h2 id="ls-list-files"><a href="#ls-list-files" class="headerlink" title="ls (list files)"></a>ls (list files)</h2><blockquote>
<p>用于显示目录内容，它的使用权限是所有用户。<br>语法:<br></p>
</blockquote>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">ls [options] 文件名</span><br></pre></td></tr></tbody></table></figure>
<p> <strong>ls -F</strong></p>
<blockquote>
<p>在每一个文件的末尾加上一个字符说明该文件的类型，例如：<br></p>
</blockquote>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">/     表示目录&lt;br&gt;</span><br><span class="line">*     表示可执行文件&lt;br&gt;</span><br><span class="line">@     表示符号链接&lt;br&gt;</span><br><span class="line">|     表示管道文件&lt;br&gt;</span><br><span class="line">=     表示socket文件&lt;br&gt;</span><br></pre></td></tr></tbody></table></figure>
<p> <strong>ls-a(all)</strong></p>
<blockquote>
<p>列出所有的文件，包括以’ . ’开头的隐藏文件<br><br>刚刚测试了一下, 所有目录的文件中都有<code>. (当前目录)</code>以及<code>..(父目录)</code>,以便随时进行目录的返回<br><strong>ls-l(long)与ls -lh(human)</strong><br>列出文件的详细信息，如创建者、创建时间、文件的读写权限等。<br><br>与ls -l不同的是<code>ls -lh</code>现实的文件大小是转化唯有单位的易读的数据, 而<code>ls -l</code>则直接显示字节数.<br>而ls -l得到的结果如下<br>[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-Eqv82uIv-1583418710740)(<a href="https://i.imgur.com/reARS6E.png)]" target="_blank" rel="noopener">https://i.imgur.com/reARS6E.png)]</a><br>上图中, 第一组数的第一位标识文件类型. 后九位(xwr-组成)分三组, 每组三位分别表示<code>文件所有者</code>, <code>所有者所在的组</code>以及<code>其他用户</code>对该文件的权限. (可读, 可写, 可执行)<br><br>如果不同字母表示权限, 还可以用0~7的数字标识每组的权限.<br><br>这样的话, 777 就对应于rwx, 000 对应于—.<br><br>这点后面命令要用到.</p>
</blockquote>
<p><strong>ls -t</strong> </p>
<blockquote>
<p>按时间进行文件的排序</p>
</blockquote>
<p><strong>ls -R(recurse)</strong></p>
<blockquote>
<p>递归地列出所有的子目录及子目录中的文件。 </p>
</blockquote>
<p><strong>ls -S</strong>   </p>
<blockquote>
<p>以文件的大小进行降序排序</p>
</blockquote>
<h2 id="rm-或rmdir"><a href="#rm-或rmdir" class="headerlink" title="rm(或rmdir)"></a>rm(或rmdir)</h2><blockquote>
<p>语法</p>
<figure class="highlight plain"><figcaption><span>[options] [file name]```</span></figcaption><table><tbody><tr><td class="code"><pre><span class="line"></span><br><span class="line">**rm -r**</span><br><span class="line">&gt;递归删除文件夹</span><br><span class="line"></span><br><span class="line">**rm -rf**</span><br><span class="line">&gt;强制删除</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">## 切换root/切换用户</span><br><span class="line">&gt;方法一: ```su root </span><br></pre></td></tr></tbody></table></figure>
<p>这样的话需要输入root密码, 很多人并没有设置过. 因为linux在安装时会自动生成一个默认密码.所以在使用前需要先重新设定密码:<br>执行<code>sudo passwd</code>,输入两次密码,enter就可以了.<br>方法二:<code>sudo -i</code><br>这时候可能要你输入密码, 只要输入你当前用户的登录密码就好了.<br></p>
</blockquote>
<blockquote>
<p>异同: 相同之处很明显, 都可以以管理员身份操作.<br>而不同之处在于su仅仅取得root权限, 工作环境不变，而sudo是取得root的权限后进入root工作环境. 这个从英文命名上理解比较好</p>
</blockquote>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">su</span><br><span class="line">switch user</span><br></pre></td></tr></tbody></table></figure>
<p>而sudo则是</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">sudo</span><br><span class="line">super-user-do</span><br></pre></td></tr></tbody></table></figure>

<h2 id="chmod-change-mode"><a href="#chmod-change-mode" class="headerlink" title="chmod (change-mode)"></a>chmod (change-mode)</h2><blockquote>
<p>语法:</p>
</blockquote>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">chmod [options] [权限数值] [文件名]</span><br></pre></td></tr></tbody></table></figure>
<blockquote>
<p>options当然可有可无.<br><br>还可以<code>mkdir -m [权限数值] [file name]</code><br>这里说一下, 系统默认新建文件夹的权限是775, 新建文件的权限是664</p>
</blockquote>
<blockquote>
<p>chmod 的操作是只针对所描述的对象的.<br>例如: 之前 a.txt的属性是777<br>chmod o=x a.txt后, 它的权限是771</p>
</blockquote>
<h2 id="chown-change-owner"><a href="#chown-change-owner" class="headerlink" title="chown(change-owner)"></a>chown(change-owner)</h2><p>更改用户群组</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">chown owner::group filelist</span><br></pre></td></tr></tbody></table></figure>

<h2 id="usermod-user-modify"><a href="#usermod-user-modify" class="headerlink" title="usermod(user-modify)"></a>usermod(user-modify)</h2><blockquote>
<p>设置用户相关<br>更改用户shell的时候可用usermod -s, 前提是你当前用户有root权限</p>
</blockquote>
<h2 id="mv"><a href="#mv" class="headerlink" title="mv"></a>mv</h2><blockquote>
<p>两个功能:<br>1.重命名</p>
</blockquote>
<figure class="highlight plain"><figcaption><span>[filename] [newname]```</span></figcaption><table><tbody><tr><td class="code"><pre><span class="line">2.移动文件</span><br><span class="line">```mv [file name] [new path]</span><br></pre></td></tr></tbody></table></figure>
<p>在使用其移动功能时, 注意../的使用</p>
<h2 id="cp"><a href="#cp" class="headerlink" title="cp"></a>cp</h2><p>复制文件</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">cp [file name] [new path]</span><br></pre></td></tr></tbody></table></figure>

<p>如果要将一个子目录copy到另一个目录下时, 需要加上 -r 选项;<br><br>使用cp命令时, 如不特殊指定, 那么文件的更改时间是最新一次的改动时间, 而文件夹则不会改变</p>
<blockquote>
<p>这里关于<code>cp -r</code>举个栗子,  pic1所描述的系统是文件<code>/dir1/dir2</code>, <code>/dir1/test.txt</code>, 以及<code>/dir3</code>.<br>[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-Yd4q1fkj-1583418710747)(<a href="https://i.imgur.com/Q1tddNr.png)]" target="_blank" rel="noopener">https://i.imgur.com/Q1tddNr.png)]</a><br>此时如果执行<code>cp /dir1/* /dir2</code>的话,只有<code>test.txt</code>copy到了dir3<br>[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-vDkCKOg5-1583418710749)(<a href="https://i.imgur.com/lKnOwuV.png)]" target="_blank" rel="noopener">https://i.imgur.com/lKnOwuV.png)]</a><br>而<code>cp -r /dir1/* /dir2</code>则会将dir1<font color="red">中</font>的内容全都copy.<br>而<code>cp /dir1 /dir2</code>则会直接提示操作失败, 因为这里cp的对象是整个/dir1文件夹. 而之前的cp操作对象是/dir1<font color="red">下</font>的所有文件及目录, 所以即使不加 -r 也可以把非目录文件copy到对应目录下.</p>
<p>Over~<br></p>
</blockquote>
<h2 id="grep"><a href="#grep" class="headerlink" title="grep"></a>grep</h2><blockquote>
<p>在指定文件中搜索特定的内容，并将含有这些内容的行输出.</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">&gt;grep [options] [关键字] [搜索目标]</span><br></pre></td></tr></tbody></table></figure>
<p><font color="red"><strong>tips:</strong></font>这里的搜索目标应该是普通文本.</p>
</blockquote>
<p><strong>grep -n</strong></p>
<blockquote>
<p>显示搜索的关键字在文本中对应的行数</p>
</blockquote>
<p><strong>grep -v</strong></p>
<blockquote>
<p>显示文本所有内容,除了[关键字]</p>
</blockquote>
<p><strong>grep -c</strong></p>
<blockquote>
<p>显示关键字出现的次数</p>
</blockquote>
<h2 id="find-默认递归"><a href="#find-默认递归" class="headerlink" title="find(默认递归)"></a>find(默认递归)</h2><p>查找文件</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">find [path] [options] [file name]</span><br></pre></td></tr></tbody></table></figure>

<p>  <strong>find [path] -name</strong></p>
<blockquote>
<p>后接指定的文件名，支持通配符</p>
</blockquote>
<p> <strong>find [path] -user</strong></p>
<blockquote>
<p>后接所要查找的文件的归属者（用户）</p>
</blockquote>
<p> <strong>find [path] -size</strong> </p>
<blockquote>
<p>后接文件大小, 形如<br></p>
</blockquote>
<figure class="highlight plain"><figcaption><span>. -size +4k```就是在当前路径下递归查找大于4k的文件</span></figcaption><table><tbody><tr><td class="code"><pre><span class="line"></span><br><span class="line">## sed</span><br><span class="line">&gt;编辑文本, 显示指定行数的内容</span><br><span class="line">&gt;```cpp</span><br><span class="line">&gt;sed -n 'x,yp' filename</span><br><span class="line">&gt;//用以显示x,y行的内容</span><br><span class="line">&gt;</span><br></pre></td></tr></tbody></table></figure>

<h2 id="内存"><a href="#内存" class="headerlink" title="内存"></a>内存</h2><blockquote>
<figure class="highlight plain"><figcaption><span>-m```查看内存<br></span></figcaption><table><tbody><tr><td class="code"><pre><span class="line">&gt;```fdisk -l ```查看系统物理内存&lt;br&gt; </span><br><span class="line">查看硬盘和分区的详细信息（需要root或超级用户的权限）  </span><br><span class="line">           </span><br><span class="line">&gt;```df -h```查看磁盘分区的总容量、已用容量等信息</span><br><span class="line"></span><br><span class="line">&gt;```du -sh```查看磁盘文件已用容量，以指定目录下的子目录为单位，显示每个子目录内所有档案所占用的磁盘空间大小。</span><br><span class="line"></span><br><span class="line">&gt;```lsblk```查看硬盘和分区分布</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">## head &amp; tail</span><br><span class="line">```head(tail) -n filelist </span><br></pre></td></tr></tbody></table></figure>
<p>查看一个或多个文件的首(末)n行</p>
</blockquote>
<h2 id="ps-process-status"><a href="#ps-process-status" class="headerlink" title="ps(process-status)"></a>ps(process-status)</h2><p>查看执行ps命令的那个时刻的那些进程．</p>
<p>如果想要动态的显示进程信息，就可以使用top命令。</p>
<p>ps -l查看详细信息<br><img src="https://img-blog.csdnimg.cn/20200313220907920.png" alt="在这里插入图片描述"><br>S的标识符 | 含义<br>— | —<br>D  | 不可中断<br>R(Runable) | 正在运行<br>S(Sleeping) | 正在休眠<br>T(trance) | 停止<br>Z(Zombie) | 僵尸进程</p>
<h2 id="文件压缩"><a href="#文件压缩" class="headerlink" title="文件压缩"></a>文件压缩</h2><table>
<thead>
<tr>
<th>压缩</th>
<th>解压</th>
</tr>
</thead>
<tbody><tr>
<td>gzip</td>
<td>gzip -d 或gunzip</td>
</tr>
<tr>
<td>bzip2</td>
<td>bzip2 -d</td>
</tr>
<tr>
<td>tar -zcvf</td>
<td>tar -zxvf (.gz)</td>
</tr>
<tr>
<td>tar -jcvf</td>
<td>tar -jxvf (.bz2)</td>
</tr>
<tr>
<td>tar -c</td>
<td>tar -x</td>
</tr>
<tr>
<td>-k可以保留原文件压缩</td>
<td></td>
</tr>
<tr>
<td>- 解压后的文件最后更改日期是和原文件相同的, 和解压时间无关</td>
<td></td>
</tr>
<tr>
<td>- tar解压后原文件存在</td>
<td></td>
</tr>
</tbody></table>
<h1 id="vim小tips"><a href="#vim小tips" class="headerlink" title="vim小tips"></a>vim小tips</h1><ul>
<li>x 也是剪切，使用后p命令可以粘贴出最近一次删除的内容。<br>目前接触到的x，d命令都是剪切，好像没有直接删除的，猜想删除就是在剪切的基础上实现的（类似于cp和mv的关系）；</li>
</ul>
<ul>
<li>除:wq外，ZZ也可以实现保存并退出的功能。（具体区目前别没有查到）；</li>
</ul>
<ul>
<li>:w是当前路径保存，后面还可以加上新路径， 实现“另存为”的功能；</li>
</ul>
<ul>
<li>vim 可以连续打开多个文件：vim file1 file2，然后使用命令:bn和:bp进行切换。或者vim打开后，使用:open filename来打开另一个文件；</li>
</ul>
<ul>
<li>移动光标时，<br>G按行移动：nG是到n行，G到末行，gg到首行；<br>w按单词移动（以空格为区分）：w到达下一个词首，e到达下个词尾；</li>
</ul>
<ul>
<li>%进行括号匹配（当前光标必须在括号的一端上，否则无意义）；</li>
</ul>
<ul>
<li>*和#，快速匹配全文中当前光标所在的单词，n是下一个,N上一个（对，类似于/pattern查找）；</li>
</ul>
<ul>
<li>/key\c不区分大小写，key、KeY都可以被匹配<br>/key\C区分大小写；</li>
</ul>
<ul>
<li><p>:s（substitute）命令用来查找和替换字符串。</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">:[range] s/before/after/tag</span><br></pre></td></tr></tbody></table></figure>
<p>ranges填写查找范围．1,7 s/mian/main/g就是把mian替换为．</p>
</li>
<li><p>: set nu可产生编号</p>
</li>
</ul>
<h1 id="更改shell"><a href="#更改shell" class="headerlink" title="更改shell"></a>更改shell</h1><figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">sudo vi /etc/passwd</span><br><span class="line">或</span><br><span class="line">sudo usermod -s /bin/bash</span><br></pre></td></tr></tbody></table></figure>

<h1 id="增删su角色"><a href="#增删su角色" class="headerlink" title="增删su角色"></a>增删su角色</h1><p>增:</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">sudo adduser username sudo</span><br></pre></td></tr></tbody></table></figure>
<p>删:</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">sudo deluser username sudo</span><br></pre></td></tr></tbody></table></figure>
<h1 id="增加用户"><a href="#增加用户" class="headerlink" title="增加用户"></a>增加用户</h1><figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">supo useradd [-g group] newuser  -m</span><br><span class="line">或</span><br><span class="line">adduser</span><br></pre></td></tr></tbody></table></figure>
<p>-g 组</p>
<p>-m /home下生成newuser的家目录~</p>
<h1 id="xdg-open"><a href="#xdg-open" class="headerlink" title="xdg-open"></a>xdg-open</h1><p> 以默认方式打开文件</p>
<h1 id="swp-文件"><a href="#swp-文件" class="headerlink" title="swp 文件"></a>swp 文件</h1><blockquote>
<p>刚刚执行 ls -a 看到的, 网上查了一下, 就大概说一下<br><br>这个是在使用vim编辑文本然后非正常退出后产生的备份文件. 严格地说是在你一打开vim, 这额文件就产生了, 如果你正常退出, 它是不会保存的.<br><br>所以这个文件算是vim比较人性化的地方吧.<br>具体恢复方法如下<br><code>vi -r [file name]</code></p>
</blockquote>
<h1 id="一些小知识"><a href="#一些小知识" class="headerlink" title="一些小知识"></a>一些小知识</h1><ul>
<li><p>usr是Unix System Resource的简称, <font color="red">不是什么user</font></p>
</li>
<li><p>linux用户目录一般在 /home/下</p>
</li>
<li><p>R一般表示递归(目录下所有文件及子目录)   recursion</p>
</li>
<li><p>r一般表示逆序   reverse</p>
</li>
<li><p>ls -ld显示自身信息<br>ls -l(long)<br><br>ls -rt(r= reverse t = time)</p>
</li>
</ul>
<blockquote>
<p><font color="blue," size="15"> 注意各种命令配合管道操作!</font></p>
</blockquote>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/post/16107.html</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If <a id="more"></a>you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></tbody></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></tbody></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></tbody></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></tbody></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>hexo测试</category>
      </categories>
  </entry>
  <entry>
    <title>shell编程(三)</title>
    <url>/post/47b27393.html</url>
    <content><![CDATA[<h2 id="shell中的数值处理"><a href="#shell中的数值处理" class="headerlink" title="shell中的数值处理"></a>shell中的数值处理</h2><p>Linux中bash的变量值是以字符串的形式存储的，所以如果想当作数字使用的话需要进行转换．（前面已经用到了一些，但没有系统的总结）<br><br>此外，Shell中所有的算术运算都被当作整数运算，所以在有浮点数参与时要特别处理.<a id="more"></a></p>
<h2 id="let"><a href="#let" class="headerlink" title="let"></a>let</h2><p>计算算式的值，使用shell变量的值的时候不用$</p>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">! /bin/bash</span></span><br><span class="line">x=5 y=6</span><br><span class="line">let t=x*y</span><br><span class="line">echo $t</span><br><span class="line"><span class="meta">#</span><span class="bash">运行结果为11</span></span><br></pre></td></tr></tbody></table></figure>

<h2 id="expression"><a href="#expression" class="headerlink" title="$((expression))"></a>$((expression))</h2><p>用于计算expression的值</p>
<h2 id="expr"><a href="#expr" class="headerlink" title="expr"></a>expr</h2><figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">expr args</span><br></pre></td></tr></tbody></table></figure>
<p>将它的参数当作表达式求值,  这里注意参数间的空格<br><br>例如<br></p>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">a =$(expr $x+1)</span><br><span class="line">或</span><br><span class="line">a=`expr $x+1`</span><br></pre></td></tr></tbody></table></figure>
<br>
args可以是数值计算也可以是逻辑判断<br>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">/#</span><span class="bash">! /bin/bash</span></span><br><span class="line">a=5</span><br><span class="line">b=6</span><br><span class="line">expr  $a \&gt; $b</span><br><span class="line">\#判断式为真则输1, 否则输出0</span><br></pre></td></tr></tbody></table></figure>

<h2 id="shell中的数组"><a href="#shell中的数组" class="headerlink" title="shell中的数组"></a>shell中的数组</h2><h3 id="声明方式"><a href="#声明方式" class="headerlink" title="声明方式"></a>声明方式</h3><figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">\#一</span><br><span class="line">array_name[num]=value</span><br><span class="line">array[1]="Hello"</span><br><span class="line">array[2]="Giao"</span><br><span class="line">\#二</span><br><span class="line">array=(value1 value2 [num]=value)</span><br><span class="line">array=(Hello  Giao [4]=World)</span><br><span class="line">\#三</span><br><span class="line">declare -a arr=(1 2 3 4)</span><br></pre></td></tr></tbody></table></figure>
<p><br><br></p>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">\#输出所有的非空元素</span><br><span class="line"><span class="meta">$</span><span class="bash">{array_name [*]}</span></span><br><span class="line"></span><br><span class="line">\#输出已赋值的元素个数(空也算)</span><br><span class="line"><span class="meta">$</span><span class="bash">{<span class="comment">#array_name [@]}</span></span></span><br><span class="line">\#或</span><br><span class="line"><span class="meta">$</span><span class="bash">{<span class="comment">#array_name [*]}</span></span></span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">\#key对应的元素长度</span><br><span class="line"><span class="meta">$</span><span class="bash">{<span class="comment">#array_name[key]}</span></span></span><br></pre></td></tr></tbody></table></figure>
<p>具体如下图<br><img src="https://img-blog.csdnimg.cn/20200325172702168.png" alt="alt=&quot;数组元素长度&quot;"></p>
<h3 id="shell中数组的删除方式"><a href="#shell中数组的删除方式" class="headerlink" title="shell中数组的删除方式"></a>shell中数组的删除方式</h3><figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">declare -a arr=(1 2 3)#声明arr数组</span><br><span class="line">unset arr[0]#删除arr的第零个元素</span><br><span class="line">unset arr#删除数组arr</span><br></pre></td></tr></tbody></table></figure>

<h3 id="shell数组的复制"><a href="#shell数组的复制" class="headerlink" title="shell数组的复制"></a>shell数组的复制</h3><p> 因为要复制全部元素，参照上面就知道需要用到<code>arr[*]</code>和<code>arr[@]</code>了，在前面的演示中，知道他们都可以表示全部元素．而它们的区别也类似于$*与$@加不加双引号的区别了.</p>
<p>首先<code>b=${arr[*}</code>就是表示将a复制给b.</p>
<p>同样的b都会得到a的全部元素,  而如果加上双引号变成<code>b=${"arr[*]"}</code>的话,  无论a中有多少元素,  都将被看做一个元素复制给b,    也就是说b只有一个元素.</p>
<h2 id="shell函数"><a href="#shell函数" class="headerlink" title="shell函数"></a>shell函数</h2><figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">func_name(pare)</span><br><span class="line">{</span><br><span class="line"> 	comamand_list</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>在函数体内声明的局部变量需要用<code>local</code>修饰,  表明那是局部变量,    局部变量在函数调用结束后销毁. </p>
<p><br><br><br></p>
<h3 id="Here"><a href="#Here" class="headerlink" title="Here!"></a><font color="red">Here!</font></h3><p><font color="red">shell中的shift命令:  将脚本传入的参数左移一位,  即: 原来的让第n+1位参数变成第n位</font></p><font color="red">
</font><script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>shell</tag>
      </tags>
  </entry>
  <entry>
    <title>二叉树遍历</title>
    <url>/post/29933.html</url>
    <content><![CDATA[<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">在一棵树中,顶点p是顶点v的父亲,则它们的高度的关系是height(v) &lt; height(p)</span><br></pre></td></tr></tbody></table></figure>
<br>
今天的内容主要有二叉树节点BinNode的建立,二叉树的前,中,层次遍历.
主要参照邓俊辉老师的讲解.<a id="more"></a>

<h1 id="BinNode"><a href="#BinNode" class="headerlink" title="BinNode"></a>BinNode</h1><p>我这里用到的是结构体,其他也可以.</p>
<figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">BinNode</span></span></span><br><span class="line"><span class="class">{</span></span><br><span class="line">    T data;</span><br><span class="line">    BinNode&lt;T&gt;* parent;</span><br><span class="line">    BinNode&lt;T&gt;* lc;<span class="comment">//左孩子</span></span><br><span class="line">    BinNode&lt;T&gt;* rc;<span class="comment">//右孩子</span></span><br><span class="line">    <span class="keyword">int</span> height;</span><br><span class="line">    <span class="comment">//构造函数</span></span><br><span class="line">    BinNode():parent(<span class="literal">NULL</span>),lc(<span class="literal">NULL</span>),rc(<span class="literal">NULL</span>),height(<span class="number">0</span>){}</span><br><span class="line">    BinNode(T _data,BinNode&lt;T&gt;* _parent):data(_data),parent(_parent){}</span><br><span class="line">    <span class="comment">//把e当作当前节点的左孩子插入(默认左孩子为空)</span></span><br><span class="line">    <span class="function">BinNode&lt;T&gt;* <span class="title">InsAslc</span><span class="params">(T <span class="keyword">const</span>&amp; e)</span></span>;</span><br><span class="line">    <span class="comment">//把e当作当前节点的右孩子插入(默认you孩子为空)</span></span><br><span class="line">    <span class="function">BinNode&lt;T&gt;* <span class="title">InsAsrc</span><span class="params">(T <span class="keyword">const</span>&amp; e)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">preOrder</span><span class="params">(BinNode&lt;T&gt;* x)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">inOrder</span><span class="params">(BinNode&lt;T&gt;* x)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">levelOrder</span><span class="params">(BinNode&lt;T&gt;* x)</span></span>;</span><br><span class="line">};</span><br><span class="line"><span class="comment">//把e当作当前节点的左孩子插入(默认左孩子为空)</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">BinNode&lt;T&gt;* BinNode&lt;T&gt;::InsAslc(T <span class="keyword">const</span>&amp; e)</span><br><span class="line">{</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.lc= <span class="keyword">new</span> BinNode(e,<span class="keyword">this</span>);</span><br><span class="line">}</span><br><span class="line"><span class="comment">//把e当作当前节点的右孩子插入(默认you孩子为空)</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">BinNode&lt;T&gt;* BinNode&lt;T&gt;::InsAsrc(T <span class="keyword">const</span>&amp; e)</span><br><span class="line">{</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.rc= <span class="keyword">new</span> BinNode(e,<span class="keyword">this</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h1 id="先序遍历"><a href="#先序遍历" class="headerlink" title="先序遍历"></a>先序遍历</h1><figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">//先序遍历</span></span><br><span class="line"><span class="comment">//递归实现</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">void</span> BinTree&lt;T&gt;::preOrder(BinNode&lt;T&gt;* x)</span><br><span class="line">{</span><br><span class="line">    <span class="keyword">if</span>(!x)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;x-&gt;data;</span><br><span class="line">    preOrder(x-&gt;lc);</span><br><span class="line">    preOrder(x-&gt;rc);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>下面的是迭代实现</p>
<figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> BinTree&lt;T&gt;::preOrder(BinNode&lt;T&gt;*x)</span><br><span class="line">{</span><br><span class="line">    <span class="built_in">stack</span>&lt;BinNode&lt;T&gt;*&gt; s;</span><br><span class="line">    <span class="keyword">if</span>(x)</span><br><span class="line">        s.push(x);</span><br><span class="line">    <span class="keyword">while</span>(!s.empty())</span><br><span class="line">    {</span><br><span class="line">        BinNode* z= s.top();</span><br><span class="line">        s.pop();</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;z-&gt;data;</span><br><span class="line">        <span class="keyword">if</span>(z-&gt;rc)s.push(z-&gt;rc);</span><br><span class="line">        <span class="keyword">if</span>(z-&gt;lc)s.push(z-&gt;lc);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h1 id="中序遍历"><a href="#中序遍历" class="headerlink" title="中序遍历"></a>中序遍历</h1><figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">//中序遍历</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">void</span> BinTree&lt;T&gt;::inOrder(BinNode&lt;T&gt;* x)</span><br><span class="line">{</span><br><span class="line">    <span class="keyword">if</span>(!x)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    inOrder(x-&gt;lc);</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;x-&gt;data;</span><br><span class="line">    inOrder(x-&gt;rc);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>


<p>下面的是迭代实现</p>
<figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> BinTree&lt;T&gt;::inOrder(BinNode&lt;T&gt;* x)</span><br><span class="line">{</span><br><span class="line">    <span class="built_in">stack</span>&lt;BinNode&lt;T&gt;*&gt; s;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(!s.empty()||x)</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">while</span>(x)</span><br><span class="line">        {</span><br><span class="line">            s.push(x);</span><br><span class="line">            x= x-&gt;lc;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">while</span>(!s.empty())</span><br><span class="line">        {</span><br><span class="line">            x= s.top;</span><br><span class="line">            s.pop();</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;x-&gt;data;</span><br><span class="line">            <span class="keyword">if</span>(x-&gt;rc)</span><br><span class="line">                x= x-&gt;rc;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h1 id="层次遍历"><a href="#层次遍历" class="headerlink" title="层次遍历"></a>层次遍历</h1><figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">void</span> BinTree&lt;T&gt;::levelOrder(BinNode&lt;T&gt;* x)</span><br><span class="line">{</span><br><span class="line">    <span class="built_in">queue</span>&lt;BinNode&lt;T&gt;* &gt; q;</span><br><span class="line">    q.push(x);</span><br><span class="line">    <span class="keyword">while</span>(!q.empty())</span><br><span class="line">    {</span><br><span class="line">        BinNode&lt;T&gt;* z= q.front();</span><br><span class="line">        q.pop();</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;z-&gt;data;</span><br><span class="line">        <span class="keyword">if</span>(z-&gt;lc)</span><br><span class="line">            q.push(z-&gt;lc);</span><br><span class="line">        <span class="keyword">if</span>(z-&gt;rc)</span><br><span class="line">            q.push(z-&gt;rc);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<hr>
<p>　　遍历其实不难理解，尤其是递归算法。下面谈谈我对非递归，也就是迭代算法的认识。<br>以先序遍历为例，我们知道，先序遍历就是VLR的流程，所以第一个visit的必定是根节点；而又因为是非递归的方法，所以我们需要借助其他的数据结构来存储节点：这里主要有栈(LIFO)和队列(FIFO)。<br><br>　　区别如下 <img src="https://i.loli.net/2020/02/07/d2sJBWSPr8ZgFnt.png" alt="左边为栈,右边为队列"><br>图画的乱糟糟但确实有助于我理解，不懂的可以自己画画。<br><br>　　最后呢是用栈来存储选定了存储结构，接下来的事就比较简单了。首先把便利的根节点存入栈中，然后while判空为真就停止，while里取出栈顶元素，visit一下，然后pop。！！！！！接下来要把子女节点也加到栈中，因为栈的LIFO原则，所以先让右孩子进，然后是左孩子，如是循环即可。</p>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>数据结构</category>
        <category>二叉树</category>
      </categories>
  </entry>
  <entry>
    <title>二叉树高度</title>
    <url>/post/42727.html</url>
    <content><![CDATA[<h1 id="求二叉树高度"><a href="#求二叉树高度" class="headerlink" title="求二叉树高度"></a>求二叉树高度</h1><h2 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归<a id="more"></a></h2><figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">height</span><span class="params">(BinNode* root)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="keyword">if</span>(!root)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> m= height(root-&gt;lc);</span><br><span class="line">	<span class="keyword">int</span> n= height(root-&gt;rc);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> m &gt; n ? m+<span class="number">1</span> : n+<span class="number">1</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>2333,目前就会看课本上的这一种方法,以后见到了在更吧.</p>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>数据结构</category>
        <category>二叉树</category>
      </categories>
  </entry>
  <entry>
    <title>shell编程(二)</title>
    <url>/post/394153b8.html</url>
    <content><![CDATA[<h1 id="控制结构语句"><a href="#控制结构语句" class="headerlink" title="控制结构语句"></a>控制结构语句</h1><p>主要内容</p>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">if</span><br><span class="line">case if</span><br><span class="line">for</span><br><span class="line">while </span><br><span class="line">until</span><br></pre></td></tr></tbody></table></figure>
<a id="more"></a>
<br>

<h2 id="if的基本用法"><a href="#if的基本用法" class="headerlink" title="if的基本用法"></a>if的基本用法</h2><figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">if a</span><br><span class="line">then </span><br><span class="line">	b</span><br><span class="line">fi</span><br><span class="line">------------</span><br><span class="line">if a</span><br><span class="line">then </span><br><span class="line">	b</span><br><span class="line">else</span><br><span class="line">	c</span><br><span class="line">fi</span><br><span class="line">-----------</span><br><span class="line">if a</span><br><span class="line">then</span><br><span class="line">	b</span><br><span class="line">elif a2</span><br><span class="line">then </span><br><span class="line">	b2</span><br><span class="line">else </span><br><span class="line">	c</span><br><span class="line">fi</span><br></pre></td></tr></tbody></table></figure>
<h2 id="shell编程中的判等"><a href="#shell编程中的判等" class="headerlink" title="shell编程中的判等"></a>shell编程中的判等</h2><p><font color="red">注意空格!!!!!</font><br> |      |判等| 不等| 为空(空为真)| 非空(非空为真)|<br> |—–| —– |——-|——-|—-|<br>|字符串  | str1 = str2 |str1 != str2| -z str|-n str|</p>
<table>
<thead>
<tr>
<th align="center"></th>
<th align="center">判等</th>
<th>不等</th>
<th>大于</th>
<th>大于等于</th>
<th>小于</th>
<th>小于等于</th>
</tr>
</thead>
<tbody><tr>
<td align="center">算术</td>
<td align="center">form1 -eq form2</td>
<td>-ne</td>
<td>-gt</td>
<td>-ge</td>
<td>-lt</td>
<td>-le</td>
</tr>
<tr>
<td align="center">(<strong>注:算术运算的后五种使用方法同第一个</strong>)</td>
<td align="center"></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<p>这里添加两个if判断条件<br><img src="https://img-blog.csdnimg.cn/20200323115342836.png" alt="在这里插入图片描述"></p>
<h2 id="for语句"><a href="#for语句" class="headerlink" title="for语句"></a>for语句</h2><figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">for varieble in argument-list</span><br><span class="line">do</span><br><span class="line">	command_list</span><br><span class="line">done</span><br></pre></td></tr></tbody></table></figure>
<p>还有最经典的for循环!!</p>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">注意这里是两层括号</span></span><br><span class="line">for((num=1;num&lt;n;num++));do</span><br><span class="line">	command_list</span><br><span class="line">done</span><br></pre></td></tr></tbody></table></figure>

<hr>
<p>du -sh filename 显示文件大小及名称<br>eval 二次扫描</p>
<hr>
<p>小tip:  在shell编程中,  如果给一个变量赋值 如 :  a=5;<br><br>那么echo a得到的就是5;<br>echo $a 得到的也是5;<br>区别是,  $a可以当作数字看待<br>所以输出的第一个是字符串的5,  第二个是数字5</p>
<h2 id="while语句"><a href="#while语句" class="headerlink" title="while语句"></a>while语句</h2><figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">while expression</span><br><span class="line">do </span><br><span class="line">	command_list</span><br><span class="line">done</span><br></pre></td></tr></tbody></table></figure>

<h2 id="until"><a href="#until" class="headerlink" title="until"></a>until</h2><figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">until expression</span><br><span class="line">do </span><br><span class="line">	command_list</span><br><span class="line">done</span><br></pre></td></tr></tbody></table></figure>

<h1 id="case"><a href="#case" class="headerlink" title="case"></a>case</h1><figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">case variable in</span><br><span class="line">	pattern1)  command_list1</span><br><span class="line">		;;</span><br><span class="line">	pattern2)  command_list2</span><br><span class="line">		;;</span><br><span class="line">	pattern3)  command_list3</span><br><span class="line">		;;</span><br><span class="line">esac</span><br></pre></td></tr></tbody></table></figure>

<h2 id="简单计算"><a href="#简单计算" class="headerlink" title="简单计算"></a>简单计算</h2><p>在做计算时，如果是浮点数计算，一定要用scale指明保留小数位数.<br>使用<em>进行乘法计算时应注意避免歧义,  尽量使用    \\</em> ．</p>
<h2 id="break和continue"><a href="#break和continue" class="headerlink" title="break和continue"></a>break和continue</h2><p>类似于C语言中的用法，continue用于结束当前次循环，break用于跳出循环.</p>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>shell</tag>
      </tags>
  </entry>
  <entry>
    <title>关于雅克比迭代, 高斯塞德尔迭代以及SOR迭代的C++实现</title>
    <url>/post/95445e9a.html</url>
    <content><![CDATA[<p>算法不难，只要理解Jacobi的算法另外两种就很简单了，因为他们都是建立在Jacobi迭代的基础上．<br>首先讲一下程序，主要是由输入功能，和迭代方式调用功能实现块构成的．</p>
<a id="more"></a>

<p>点击<a href="https://pan.baidu.com/s/1Blf6Y-OaYJQZLLWBwZQUBw" target="_blank" rel="noopener">这里</a>下载源码.<br>提取码：mlpb </p>
<h1 id="程序变量"><a href="#程序变量" class="headerlink" title="程序变量"></a>程序变量</h1><figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> m; <span class="comment">//m*n的系数矩阵</span></span><br><span class="line"><span class="keyword">int</span> max_times;<span class="comment">// z最大迭代次数</span></span><br><span class="line"><span class="keyword">int</span> times = <span class="number">0</span>;<span class="comment">//当前迭代次数</span></span><br><span class="line"><span class="comment">//int mx_mis = 99999999;</span></span><br><span class="line"><span class="built_in">string</span> choice;<span class="comment">//功能选择</span></span><br><span class="line"><span class="keyword">double</span> mis;<span class="comment">//误差范围</span></span><br><span class="line"><span class="keyword">double</span> mtrx[sz][sz];<span class="comment">//系数矩阵</span></span><br><span class="line"><span class="keyword">double</span> b[sz];<span class="comment">//常数矩阵</span></span><br><span class="line"><span class="keyword">double</span> init[sz];<span class="comment">//初始向量</span></span><br><span class="line"><span class="keyword">double</span> ans[sz];<span class="comment">//答案</span></span><br><span class="line"><span class="comment">//double max_mis[sz];//</span></span><br></pre></td></tr></tbody></table></figure>
<h1 id="主程序"><a href="#主程序" class="headerlink" title="主程序"></a>主程序</h1><figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    input();</span><br><span class="line"></span><br><span class="line">    func();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h1 id="输入功能"><a href="#输入功能" class="headerlink" title="输入功能"></a>输入功能</h1><p>这里就是输入计算需要的系数矩阵,常数矩阵等基本条件.</p>
<figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span>  <span class="title">input</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"请输入迭代方式(J,GS,SOR)"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;choice;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"请输入m"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; m;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"请输入系数矩阵m*n(m)"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">for</span> ( <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++ )</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">for</span> ( <span class="keyword">int</span> j = <span class="number">0</span>; j &lt; m; j++ )</span><br><span class="line">        {</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; mtrx[i][j];</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"请输入常数矩阵b:"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">for</span> ( <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++ )</span><br><span class="line">    {</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; b[i];</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"请输入初始向量"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">for</span> ( <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++ )</span><br><span class="line">    {</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; init[i];</span><br><span class="line">        ans[i] = init[i];</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"请输入最大迭代次数:"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; max_times;</span><br><span class="line"></span><br><span class="line"><span class="comment">//    cout &lt;&lt; endl &lt;&lt; "请输入最大误差:"&lt;&lt;endl;</span></span><br><span class="line"><span class="comment">//         cin&gt;&gt;mis;</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h1 id="输出功能"><a href="#输出功能" class="headerlink" title="输出功能"></a>输出功能</h1><p>迭代结束后进行输出</p>
<figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">output</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"迭代"</span> &lt;&lt; times+<span class="number">1</span> &lt;&lt; <span class="string">"次,答案是"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">for</span> ( <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++ )</span><br><span class="line">    {</span><br><span class="line"><span class="comment">//        cout &lt;&lt; init[i] &lt;&lt; endl;</span></span><br><span class="line">        <span class="built_in">printf</span> ( <span class="string">"%.4f\t"</span>, init[i] );</span><br><span class="line">    }</span><br><span class="line">    <span class="built_in">printf</span> ( <span class="string">"\n"</span> );</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h1 id="迭代调用功能"><a href="#迭代调用功能" class="headerlink" title="迭代调用功能"></a>迭代调用功能</h1><p>为了main函数里干净点，把功能函数统统放进func里</p>
<figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">if</span>(choice==<span class="string">"J"</span>)</span><br><span class="line">        Jacobi();</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(choice==<span class="string">"GS"</span>)</span><br><span class="line">        GS();</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        SOR();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h1 id="Jacobi迭代"><a href="#Jacobi迭代" class="headerlink" title="Jacobi迭代"></a>Jacobi迭代</h1><p><img src="https://img-blog.csdnimg.cn/20200526224928180.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNzczMTY0,size_16,color_FFFFFF,t_70" alt="数值分析,雅克比迭代"></p>
<figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Jacobi</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">    {</span><br><span class="line">        mx_mis = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//根据初始向量进行向量乘法．求出每一行对应的解</span></span><br><span class="line">        <span class="comment">//把结果放在ans中</span></span><br><span class="line">        <span class="keyword">for</span> ( <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++ )</span><br><span class="line">        {</span><br><span class="line">            <span class="keyword">double</span> sum = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> ( <span class="keyword">int</span> j = <span class="number">0</span>; j &lt; m; j++ )</span><br><span class="line">            {</span><br><span class="line">                <span class="keyword">if</span> ( j != i )</span><br><span class="line">                {</span><br><span class="line">                    sum += init[j] * mtrx[i][j];</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">            ans[i] = ( b[i] - sum  ) / mtrx[i][i];</span><br><span class="line">            <span class="comment">//            if ( i &gt; 0 )</span></span><br><span class="line">            <span class="keyword">if</span> ( <span class="built_in">fabs</span> ( init[i] - ans[i] ) &gt; mx_mis )</span><br><span class="line">                mx_mis = <span class="built_in">fabs</span> ( init[i] - ans[i] );</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">//迭代完成一次, 就更新一次init数组,以便下一次迭代</span></span><br><span class="line">        <span class="keyword">for</span> ( <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++ )</span><br><span class="line">        {</span><br><span class="line">            init[i] = ans[i];</span><br><span class="line">        }</span><br><span class="line"><span class="comment">//        mx_mis=max_mis[0];</span></span><br><span class="line"><span class="comment">//        for(int i=0;i&lt;m;i++)</span></span><br><span class="line"><span class="comment">//        {</span></span><br><span class="line"><span class="comment">//            if(max_mis[i]&gt;mx_mis)</span></span><br><span class="line"><span class="comment">//                mx_mis= max_mis[i];</span></span><br><span class="line"><span class="comment">//        }</span></span><br><span class="line">        output();</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">while</span> ( ( times++ &lt; max_times ) &amp;&amp; ( mis_range &lt; mx_mis ) );</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h1 id="GS迭代"><a href="#GS迭代" class="headerlink" title="GS迭代"></a>GS迭代</h1><p>迭代格式是$$x_i^{k+1}=  \frac {1} {a_{ii}} \left(d_i-  \sum_{j=1}^{i-1}a_{ij}^{k}-\sum_{j=i+1}^{n}a_{ij}^{k+1} \right)$$<br>对比Jacobi迭代，在代码上的实现区别就是不需要ans数组暂存，直接将新的$x_i^{k+1}$赋给init[i]．自然也不需要init和ans的同步．</p>
<figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">GS</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">double</span> temp;</span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">    {</span><br><span class="line">        mx_mis = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//根据初始向量进行向量乘法．求出每一行对应的解</span></span><br><span class="line">        <span class="keyword">for</span> ( <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++ )</span><br><span class="line">        {</span><br><span class="line">            <span class="keyword">double</span> sum = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> ( <span class="keyword">int</span> j = <span class="number">0</span>; j &lt; m; j++ )</span><br><span class="line">            {</span><br><span class="line">                <span class="keyword">if</span> ( j != i )</span><br><span class="line">                {</span><br><span class="line">                    sum += init[j] * mtrx[i][j];</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">            temp = init[i];</span><br><span class="line">            init[i] = ( b[i] - sum  ) / mtrx[i][i];</span><br><span class="line">            <span class="keyword">if</span> ( <span class="built_in">fabs</span> ( init[i] - temp ) &gt; mx_mis )</span><br><span class="line">                mx_mis = <span class="built_in">fabs</span> ( init[i] - temp );</span><br><span class="line">        }</span><br><span class="line">        output();</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">while</span> ( (  times++ &lt; max_times ) &amp;&amp; ( mx_mis &gt; mis_range ) );</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h1 id="SOR迭代"><a href="#SOR迭代" class="headerlink" title="SOR迭代"></a>SOR迭代</h1><figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SOR</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">double</span> w;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"请输入松弛因子ｗ:"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; w;</span><br><span class="line">    <span class="keyword">double</span> temp;</span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">    {</span><br><span class="line">        mx_mis = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//根据初始向量进行向量乘法．求出每一行对应的解</span></span><br><span class="line">        <span class="keyword">for</span> ( <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++ )</span><br><span class="line">        {</span><br><span class="line">            <span class="keyword">double</span> sum = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> ( <span class="keyword">int</span> j = <span class="number">0</span>; j &lt; m; j++ )</span><br><span class="line">            {</span><br><span class="line">                <span class="keyword">if</span> ( j != i )</span><br><span class="line">                {</span><br><span class="line">                    sum += init[j] * mtrx[i][j];</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">            temp = init[i];</span><br><span class="line">            init[i] = init[i] + w * ( ( b[i] - sum  ) / mtrx[i][i]  - init[i] );</span><br><span class="line">            <span class="keyword">if</span> ( <span class="built_in">fabs</span> ( init[i] - temp ) &gt; mx_mis )</span><br><span class="line">                mx_mis = <span class="built_in">fabs</span> ( init[i] - temp );</span><br><span class="line">        }</span><br><span class="line">        output();</span><br><span class="line">    }<span class="keyword">while</span> ( (  times++ &lt; max_times ) &amp;&amp; ( mx_mis &gt; mis_range ) );</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>上面是注意分析，下面是源代码.<br>如有错误请多指正.</p>
<figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> sz 10</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*****************************</span></span><br><span class="line"><span class="comment">@Jacobi迭代解线性方程组</span></span><br><span class="line"><span class="comment">@author:jawi</span></span><br><span class="line"><span class="comment">@date:2020/03/03</span></span><br><span class="line"><span class="comment">@tip:本程序默认输入矩阵均为理想矩阵</span></span><br><span class="line"><span class="comment">*****************************/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">input</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Jacobi</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">GS</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SOR</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">output</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> m; <span class="comment">//m*n的系数矩阵</span></span><br><span class="line"><span class="keyword">int</span> max_times;<span class="comment">// z最大迭代次数</span></span><br><span class="line"><span class="keyword">int</span> times = <span class="number">0</span>;<span class="comment">//当前迭代次数</span></span><br><span class="line"><span class="keyword">double</span> mx_mis = <span class="number">0</span>;<span class="comment">//当前最大误差</span></span><br><span class="line"><span class="built_in">string</span> choice;<span class="comment">//功能选择</span></span><br><span class="line"><span class="keyword">double</span> mis;<span class="comment">//误差范围</span></span><br><span class="line"><span class="keyword">double</span> mtrx[sz][sz];<span class="comment">//系数矩阵</span></span><br><span class="line"><span class="keyword">double</span> b[sz];<span class="comment">//常数矩阵</span></span><br><span class="line"><span class="keyword">double</span> init[sz];<span class="comment">//初始向量</span></span><br><span class="line"><span class="keyword">double</span> ans[sz];<span class="comment">//答案</span></span><br><span class="line"><span class="keyword">double</span> mis_range;<span class="comment">//最大误差范围</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    input();</span><br><span class="line"></span><br><span class="line">    func();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">if</span> ( choice == <span class="string">"J"</span> )</span><br><span class="line">        Jacobi();</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> ( choice == <span class="string">"GS"</span> )</span><br><span class="line">        GS();</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        SOR();</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span>  <span class="title">input</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"请输入迭代方式(J,GS,SOR)"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; choice;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"请输入m"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; m;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"请输入系数矩阵m*n(m)"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">for</span> ( <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++ )</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">for</span> ( <span class="keyword">int</span> j = <span class="number">0</span>; j &lt; m; j++ )</span><br><span class="line">        {</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; mtrx[i][j];</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"请输入常数矩阵b:"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">for</span> ( <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++ )</span><br><span class="line">    {</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; b[i];</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"请输入初始向量"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">for</span> ( <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++ )</span><br><span class="line">    {</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; init[i];</span><br><span class="line">        ans[i] = init[i];</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"请输入最大迭代次数:"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; max_times;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"请输入最大误差范围:"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; mis_range;</span><br><span class="line"></span><br><span class="line"><span class="comment">//    cout &lt;&lt; endl &lt;&lt; "请输入最大误差:"&lt;&lt;endl;</span></span><br><span class="line"><span class="comment">//         cin&gt;&gt;mis;</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Jacobi</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">    {</span><br><span class="line">        mx_mis = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//根据初始向量进行向量乘法．求出每一行对应的解</span></span><br><span class="line">        <span class="comment">//把结果放在ans中</span></span><br><span class="line">        <span class="keyword">for</span> ( <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++ )</span><br><span class="line">        {</span><br><span class="line">            <span class="keyword">double</span> sum = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> ( <span class="keyword">int</span> j = <span class="number">0</span>; j &lt; m; j++ )</span><br><span class="line">            {</span><br><span class="line">                <span class="keyword">if</span> ( j != i )</span><br><span class="line">                {</span><br><span class="line">                    sum += init[j] * mtrx[i][j];</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">            ans[i] = ( b[i] - sum  ) / mtrx[i][i];</span><br><span class="line">            <span class="comment">//            if ( i &gt; 0 )</span></span><br><span class="line">            <span class="keyword">if</span> ( <span class="built_in">fabs</span> ( init[i] - ans[i] ) &gt; mx_mis )</span><br><span class="line">                mx_mis = <span class="built_in">fabs</span> ( init[i] - ans[i] );</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">//迭代完成一次, 就更新一次init数组,以便下一次迭代</span></span><br><span class="line">        <span class="keyword">for</span> ( <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++ )</span><br><span class="line">        {</span><br><span class="line">            init[i] = ans[i];</span><br><span class="line">        }</span><br><span class="line"><span class="comment">//        mx_mis=max_mis[0];</span></span><br><span class="line"><span class="comment">//        for(int i=0;i&lt;m;i++)</span></span><br><span class="line"><span class="comment">//        {</span></span><br><span class="line"><span class="comment">//            if(max_mis[i]&gt;mx_mis)</span></span><br><span class="line"><span class="comment">//                mx_mis= max_mis[i];</span></span><br><span class="line"><span class="comment">//        }</span></span><br><span class="line">        output();</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">while</span> ( ( times++ &lt; max_times ) &amp;&amp; ( mis_range &lt; mx_mis ) );</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">GS</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">double</span> temp;</span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">    {</span><br><span class="line">        mx_mis = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//根据初始向量进行向量乘法．求出每一行对应的解</span></span><br><span class="line">        <span class="keyword">for</span> ( <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++ )</span><br><span class="line">        {</span><br><span class="line">            <span class="keyword">double</span> sum = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> ( <span class="keyword">int</span> j = <span class="number">0</span>; j &lt; m; j++ )</span><br><span class="line">            {</span><br><span class="line">                <span class="keyword">if</span> ( j != i )</span><br><span class="line">                {</span><br><span class="line">                    sum += init[j] * mtrx[i][j];</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">            temp = init[i];</span><br><span class="line">            init[i] = ( b[i] - sum  ) / mtrx[i][i];</span><br><span class="line">            <span class="keyword">if</span> ( <span class="built_in">fabs</span> ( init[i] - temp ) &gt; mx_mis )</span><br><span class="line">                mx_mis = <span class="built_in">fabs</span> ( init[i] - temp );</span><br><span class="line">        }</span><br><span class="line">        output();</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">while</span> ( (  times++ &lt; max_times ) &amp;&amp; ( mx_mis &gt; mis_range ) );</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SOR</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">double</span> w;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"请输入松弛因子ｗ:"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; w;</span><br><span class="line">    <span class="keyword">double</span> temp;</span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">    {</span><br><span class="line">        mx_mis = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//根据初始向量进行向量乘法．求出每一行对应的解</span></span><br><span class="line">        <span class="keyword">for</span> ( <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++ )</span><br><span class="line">        {</span><br><span class="line">            <span class="keyword">double</span> sum = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> ( <span class="keyword">int</span> j = <span class="number">0</span>; j &lt; m; j++ )</span><br><span class="line">            {</span><br><span class="line">                <span class="keyword">if</span> ( j != i )</span><br><span class="line">                {</span><br><span class="line">                    sum += init[j] * mtrx[i][j];</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">            temp = init[i];</span><br><span class="line">            init[i] = init[i] + w * ( ( b[i] - sum  ) / mtrx[i][i]  - init[i] );</span><br><span class="line">            <span class="keyword">if</span> ( <span class="built_in">fabs</span> ( init[i] - temp ) &gt; mx_mis )</span><br><span class="line">                mx_mis = <span class="built_in">fabs</span> ( init[i] - temp );</span><br><span class="line">        }</span><br><span class="line">        output();</span><br><span class="line">    }<span class="keyword">while</span> ( (  times++ &lt; max_times ) &amp;&amp; ( mx_mis &gt; mis_range ) );</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">output</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"迭代"</span> &lt;&lt; times+<span class="number">1</span> &lt;&lt; <span class="string">"次,答案是"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">for</span> ( <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++ )</span><br><span class="line">    {</span><br><span class="line"><span class="comment">//        cout &lt;&lt; init[i] &lt;&lt; endl;</span></span><br><span class="line">        <span class="built_in">printf</span> ( <span class="string">"%.4f\t"</span>, init[i] );</span><br><span class="line">    }</span><br><span class="line">    <span class="built_in">printf</span> ( <span class="string">"\n"</span> );</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
  </entry>
  <entry>
    <title>图论基础知识</title>
    <url>/post/54576.html</url>
    <content><![CDATA[<p><font size="4">这几天在复习(学习)图论方面的知识，把网课上老师讲的，自己查的，零零散散做个汇总．</font><a id="more"></a></p>
<h1 id="图"><a href="#图" class="headerlink" title="图"></a>图</h1><h2 id="基础概念"><a href="#基础概念" class="headerlink" title="基础概念"></a>基础概念</h2><p>G=(V;E)<br>n= |V|;  e= |E|</p>
<p>顶点与边的关系.</p>
<p>邻接关系：顶点~顶点，顶点和顶点的关系</p>
<p>关联关系：顶点～边，边和组成边的顶点的关系</p>
<p>线性表：互为直接前驱和直接后继的元素才能定义邻接关系<br><br>树：互为父子的节点才能被定义为邻接关系<br><br>线性表和树是特殊的图<br>图的要求更宽泛</p>
<h2 id="有向图-amp-无向图"><a href="#有向图-amp-无向图" class="headerlink" title="有向图&amp;无向图"></a>有向图&amp;无向图</h2><p><strong>无向边(undirected graph)</strong>：构成边的顶点Ｕ和Ｖ无序，则<br>边（U，V）称为无向边</p>
<p><strong>无向图（undigraph)</strong>：构成图的边全是无向边.(关系也是无向的)<br><br><img src="https://i.imgur.com/5gP53Lr.png" alt="无向图"></p>
<p><strong>有向图(digraph)</strong>：构成图的各个边都是有向边.(关系也是有向的)<br><br><img src="https://i.imgur.com/8fiPQ06.png" alt="有向图"></p>
<h2 id="路径"><a href="#路径" class="headerlink" title="路径"></a>路径</h2><p><strong>概念(path)</strong>：一系列的顶点按照邻接关系构成的序列.</p>
<p><strong>简单路径(simple path)</strong>:一条不含重复节点的路径.</p>
<p><strong>环路(circle)</strong>：起点和重点相同的路径/<br>简单环路(simple path)：除起点、终点外,一条不含重复节点的环路.</p>
<h2 id="有向无环图-DAG"><a href="#有向无环图-DAG" class="headerlink" title="有向无环图(DAG)"></a>有向无环图(DAG)</h2><p><strong>概念</strong>：一个有向图中不包含任何环路.</p>
<h2 id="欧拉图-Eulerian-graph-—–一笔画问题"><a href="#欧拉图-Eulerian-graph-—–一笔画问题" class="headerlink" title="欧拉图(Eulerian graph)—–一笔画问题"></a>欧拉图(Eulerian graph)—–一笔画问题</h2><p><strong>欧拉路径</strong>：通过图中所有边一次且仅一次行遍所有顶点的通路称为欧拉路径.<br><br><strong>欧拉回路</strong>：通过图中所有边一次且仅一次经过所有顶点的回路称为欧拉回路.<br></p>
<p><strong>欧拉图</strong>：具有欧拉回路的图称为欧拉图.<br><br><strong>半欧拉图</strong>：具有欧拉通路的图称为半欧拉图.<br><br><strong>性质</strong>：(半)欧拉图中所有顶点的度数都是(两个奇数度顶点)偶数。<br></p>
<h2 id="哈密尔顿图"><a href="#哈密尔顿图" class="headerlink" title="哈密尔顿图"></a>哈密尔顿图</h2><p><strong>哈密尔顿回路</strong>:通过图中所有顶一次且仅一次的回路为哈密尔顿回路.<br><br><strong>哈密尔顿图</strong>：具有哈密尔顿回路的图.<br></p>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>图</tag>
      </tags>
  </entry>
  <entry>
    <title>shell编程</title>
    <url>/post/e5954c2f.html</url>
    <content><![CDATA[<h1 id="Shell程序的的变量及参数"><a href="#Shell程序的的变量及参数" class="headerlink" title="Shell程序的的变量及参数"></a>Shell程序的的变量及参数</h1><p>在shell程序中，数据用变量来存储，使用变量时不需要声明，默认所有变量类型为字符串类型．<a id="more"></a><br><img src="https://img-blog.csdnimg.cn/20200311165844920.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNzczMTY0,size_16,color_FFFFFF,t_70" alt="shell程序的参数及变量"><br>这里$*,”$@”和$@的效果是一样的.</p>
<blockquote>
<p>使用<strong>set</strong>设置位置参数.<br>形如</p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">&gt;<span class="built_in">set</span> $(ls -l)</span><br></pre></td></tr></tbody></table></figure>
<p>这样的命令则会把ls -l的结果以此作为他的参数.</p>
</blockquote>
<h1 id="常见的环境变量"><a href="#常见的环境变量" class="headerlink" title="常见的环境变量"></a>常见的环境变量</h1><table>
<thead>
<tr>
<th align="center">环境变量</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">$HOME</td>
<td align="center">当前用户主目录</td>
</tr>
<tr>
<td align="center">$PATH</td>
<td align="center">用以搜索命令的目录列表,用:分隔</td>
</tr>
<tr>
<td align="center">$PS1</td>
<td align="center">命令提示符，通常是用＄．root用户则是#</td>
</tr>
<tr>
<td align="center">$PS2</td>
<td align="center">二级提示符，用来提示后需输入，通常是＞</td>
</tr>
<tr>
<td align="center">$IFS</td>
<td align="center">内部与分隔符</td>
</tr>
</tbody></table>
<h1 id="变量的声明"><a href="#变量的声明" class="headerlink" title="变量的声明"></a>变量的声明</h1><p>在shell中，使用一般变量可以不用声明，可对于一些特殊变量需要声明．<br>声明格式：</p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line"><span class="built_in">declare</span> [options] [name=[value]]</span><br><span class="line"><span class="built_in">typeset</span> [options] [name=[value]]</span><br><span class="line"><span class="comment">#unset用于删除shell变量</span></span><br><span class="line"><span class="built_in">unset</span> name</span><br></pre></td></tr></tbody></table></figure>
<p>常用选项options:<br>-a  声明一个数组array<br>-f   声明一个函数function<br>-i   声明一个整数integer<br>-r   声明只读变量readonly<br>-x   声明全局变量,可供子进程使用</p>
<p><strong>*<font color="red" size="5">注：赋值语句中，等号前后不能有空格．<br>　　整型变量不可以被赋非整型的值</font>*</strong><br>　　<br>set用于查看本地定义的shell变量</p>
<h1 id="变量引用"><a href="#变量引用" class="headerlink" title="变量引用"></a>变量引用</h1><p>echo　$ {name:－string}<br>当变量(name)存在时，显示变量的值，否则显示string<br>echo　$ {name:＝string}<br>当变量(name)存在时，显示变量的值，否则把string赋给name，并输出<br>echo　$ {name:?string}<br>当变量(name)存在时，显示变量的值，否则显示name：string<br>echo　$ {name:=string}<br>当变量(name)存在时，显示变量的值，否则显示空</p>
<ul>
<li>用单引号将值括起来，则不允许对括号中的变量进行替换，且不做shell解释，即屏蔽了括号中特殊字符的含义<br>例如:<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">j@Ubuntu:~/pro_shell$ x='$PATH'</span><br><span class="line">j@Ubuntu:~/pro_shell$ echo $x</span><br><span class="line"><span class="meta">$</span><span class="bash">PATH</span></span><br></pre></td></tr></tbody></table></figure></li>
<li>‘\‘在Bash中被解释为转义字符，用于去除一个单个字符的特殊意义，保留跟随在之后的字符的字面值．</li>
</ul>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>-Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>shell</tag>
      </tags>
  </entry>
  <entry>
    <title>列车调度</title>
    <url>/post/36741.html</url>
    <content><![CDATA[<h1 id="列车调度"><a href="#列车调度" class="headerlink" title="列车调度"></a>列车调度</h1><p>题目详见: <a href="https://dsa.cs.tsinghua.edu.cn/oj/problem.shtml?id=1145" target="_blank" rel="noopener">https://dsa.cs.tsinghua.edu.cn/oj/problem.shtml?id=1145</a><br><br><font size="5"><strong>描述</strong></font><br><br>某列车调度站的铁道联接结构如Figure 1所示。<a id="more"></a><br><img src="https://img-blog.csdnimg.cn/2020021121313473.png" alt="figure 1"></p>
<p>其中，A为入口，B为出口，S为中转盲端。所有铁道均为单轨单向式：列车行驶的方向只能是从A到S，再从S到B；另外，不允许超车。因为车厢可在S中驻留，所以它们从B端驶出的次序，可能与从A端驶入的次序不同。不过S的容量有限，同时驻留的车厢不得超过m节。</p>
<p>设某列车由编号依次为{1, 2, …, n}的n节车厢组成。调度员希望知道，按照以上交通规则，这些车厢能否以{a1, a2, …, an}的次序，重新排列后从B端驶出。如果可行，应该以怎样的次序操作?</p>
<p><font size="5"><strong>输入</strong></font><br><br>共两行。<br>第一行为两个整数n，m。<br>第二行为以空格分隔的n个整数，保证为{1, 2, …, n}的一个排列，表示待判断可行性的驶出序列{a1，a2，…，an}。</p>
<p><font size="5"><strong>输出</strong></font><br><br>若驶出序列可行，则输出操作序列，其中push表示车厢从A进入S，pop表示车厢从S进入B，每个操作占一行。</p>
<p>若不可行，则输出No。</p>
<p><font size="5"><strong>样例</strong></font><br><br><strong>example 1</strong><br><br>Input<br></p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">5 2</span><br><span class="line">1 2 3 5 4</span><br><span class="line">​```&lt;br&gt;</span><br><span class="line">Output&lt;br&gt;</span><br></pre></td></tr></tbody></table></figure>
<p>push<br>pop<br>push<br>pop<br>push<br>pop<br>push<br>push<br>pop<br>pop</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">**example 2**&lt;br&gt;</span><br><span class="line">Input&lt;br&gt;</span><br></pre></td></tr></tbody></table></figure>
<p>5 5<br>3 1 2 4 5</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">Output&lt;br&gt;</span><br></pre></td></tr></tbody></table></figure>
<p>No</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">限制</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">1 ≤ n ≤ 1,600,000</span><br><span class="line"></span><br><span class="line">0 ≤ m ≤ 1,600,000</span><br><span class="line"></span><br><span class="line">时间：2 sec</span><br><span class="line"></span><br><span class="line">空间：256 MB</span><br><span class="line"># 思路</span><br><span class="line">这道题其实按我理解，很类似出栈序列的合法性，当然算法很不一样。我说类似判断类似出栈合法性是因为第一次看到题的时候，以为是给你一个乱序序列（12354），让你借助栈，以升序（12345）序列输出。</span><br><span class="line"></span><br><span class="line">然而并不是啊！！！所以一直看不懂样例2的no是怎么来的。</span><br><span class="line"></span><br><span class="line">纠结了好久，网上看了之后才发现问题所在。然后也发现，这种问题其实叫"栈混洗问题"。</span><br><span class="line"></span><br><span class="line">解决方法呢主要是两个一维数组，一个int栈。一维数组seq用来存储待检验的序列。另一个一维数组ans用来存储操作（因为该题如果结果为“No”是不需要输出操作的，所以要先把操作存储，然后根据最后结果判断是否输出），1代表“push",2代表"pop"。</span><br><span class="line"></span><br><span class="line">首先搞清楚输出"No"的判断条件：</span><br><span class="line">case1:栈容量溢出。</span><br><span class="line">case2:栈顶元素大于待检测序列的第一位.</span><br><span class="line"></span><br><span class="line">然后在n个循环中和seq的元素依次进行比对，若seq的元素大于循环i，那么把i入栈，ans数组增加元素1，直到他俩相等。</span><br><span class="line">如果栈顶元素等于当前seq[i]的元素，那么pop，然后ans数组增加元素0.</span><br><span class="line"># 代码</span><br><span class="line">如有错误，请多指正</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">​```cpp</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line">/**********************************</span><br><span class="line">输出NO:</span><br><span class="line">case1:栈容量溢出</span><br><span class="line">case2:栈顶元素大于待检测序列的第一位</span><br><span class="line">**********************************/</span><br><span class="line"></span><br><span class="line">template&lt;typename T&gt;</span><br><span class="line">class stack</span><br><span class="line">{</span><br><span class="line">private:</span><br><span class="line">    T* data;</span><br><span class="line">    T top;</span><br><span class="line">    int maxsize;</span><br><span class="line">public:</span><br><span class="line">    stack ( int _max )</span><br><span class="line">    {</span><br><span class="line">        maxsize = _max;</span><br><span class="line">        data = new T[maxsize];</span><br><span class="line">        top = -1;</span><br><span class="line">    }</span><br><span class="line">    void expand()</span><br><span class="line">    {</span><br><span class="line">        int newsize = maxsize * 2;</span><br><span class="line">        T *newdata = new T[newsize];</span><br><span class="line">        for ( int i = 0; i &lt; maxsize; i++ )</span><br><span class="line">            newdata[i] = data[i];</span><br><span class="line">        maxsize = maxsize * 2;</span><br><span class="line">        data = newdata;</span><br><span class="line">    }</span><br><span class="line">    void push ( T x )</span><br><span class="line">    {</span><br><span class="line">        if ( top == maxsize - 1 )</span><br><span class="line">            expand();</span><br><span class="line">        data[++top] = x;</span><br><span class="line">    }</span><br><span class="line">    void pop ()</span><br><span class="line">    {</span><br><span class="line">        if ( top &gt; 0 )</span><br><span class="line">        {</span><br><span class="line">            top--;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    bool empty()</span><br><span class="line">    {</span><br><span class="line">        return top == -1 ? true : false;</span><br><span class="line">    }</span><br><span class="line">    T gettop()</span><br><span class="line">    {</span><br><span class="line">        if ( top != -1 )</span><br><span class="line">            return data[top];</span><br><span class="line">        return -1;</span><br><span class="line">    }</span><br><span class="line">    int size()</span><br><span class="line">    {</span><br><span class="line">        return top + 1;</span><br><span class="line">    }</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">{</span><br><span class="line">    int m;//序列个数</span><br><span class="line">    int n;//栈容量</span><br><span class="line">    int j = 0;</span><br><span class="line">    int k = 0;//ans的下标</span><br><span class="line">    cin &gt;&gt; m &gt;&gt; n;</span><br><span class="line">    int seq[m];</span><br><span class="line">    int ans[2*m] ;//操作最大为2m</span><br><span class="line">    stack&lt;int&gt; s ( 100 );</span><br><span class="line"></span><br><span class="line">    for ( int i = 1; i &lt; m+1; i++ )</span><br><span class="line">        scanf ( "%d", &amp;seq[i] );</span><br><span class="line"></span><br><span class="line">    for ( int i = 1; i &lt; m+1; i++ )</span><br><span class="line">    {</span><br><span class="line">        //case2</span><br><span class="line">        if ( seq[i] &lt; s.gettop() &amp;&amp; !s.empty())</span><br><span class="line">        {</span><br><span class="line">            printf ( "No\n" );</span><br><span class="line">            return 0;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        if ( seq[i] &gt; j )</span><br><span class="line">        {</span><br><span class="line">            while ( seq[i] != j )</span><br><span class="line">            {</span><br><span class="line">                s.push ( ++j );</span><br><span class="line">                ans[k++] = 1;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        //case1</span><br><span class="line">        if ( s.size() &gt; m )</span><br><span class="line">        {</span><br><span class="line">            printf ( "No\n" );</span><br><span class="line">            return 0;</span><br><span class="line">        }</span><br><span class="line">        if ( s.gettop() == seq[i] )</span><br><span class="line">        {</span><br><span class="line">            s.pop();</span><br><span class="line">            ans[k++] = 0;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    for(int i= 0;i&lt;k;i++)</span><br><span class="line">    {</span><br><span class="line">        if(ans[i])</span><br><span class="line">            printf("push\n");</span><br><span class="line">        else</span><br><span class="line">            printf("pop\n");</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>树</tag>
      </tags>
  </entry>
  <entry>
    <title>基于virtual box 6.x.x安装Ubuntu操作系统图文教程</title>
    <url>/post/36742.html</url>
    <content><![CDATA[<h1 id="安装工具准备"><a href="#安装工具准备" class="headerlink" title="安装工具准备"></a>安装工具准备</h1><p>1.点击这里<a href="https://www.virtualbox.org/wiki/Downloads" target="_blank" rel="noopener">这里</a>下载virtual box。我现在下载的是最新版本6.1.2，日后可能会有更新，但应该改动不大。<br><br>2.点击<a href="https://ubuntu.com/download/desktop" target="_blank" rel="noopener">这里</a>下载Ubuntu，同上下载的最新版本18.04.3。<a id="more"></a><br></p>
<h1 id="配置virtual-box"><a href="#配置virtual-box" class="headerlink" title="配置virtual box"></a>配置virtual box</h1><h2 id="1-先启动virtual-box，界面如下图："><a href="#1-先启动virtual-box，界面如下图：" class="headerlink" title="1.先启动virtual box，界面如下图："></a>1.先启动virtual box，界面如下图：</h2><p><img src="https://img-blog.csdnimg.cn/20200211135042830.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNzczMTY0,size_16,color_FFFFFF,t_70" alt="图一"></p>
<h2 id="2-选择虚拟主机路径"><a href="#2-选择虚拟主机路径" class="headerlink" title="2.选择虚拟主机路径"></a>2.选择虚拟主机路径</h2><p>点击左上角的管理-全局-常规，修改”默认虚拟电脑位置”为自己设置的文件夹中.<br><br>不设置也是ok的,不过默认在c盘,你懂得~<br><img src="https://img-blog.csdnimg.cn/20200211135109139.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNzczMTY0,size_16,color_FFFFFF,t_70" alt="图二"></p>
<h2 id="3-新建虚拟机"><a href="#3-新建虚拟机" class="headerlink" title="3.新建虚拟机"></a>3.新建虚拟机</h2><p>点击标注的新建<br><img src="https://img-blog.csdnimg.cn/202002111355250.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNzczMTY0,size_16,color_FFFFFF,t_70" alt="图三"></p>
<p>输入虚拟机名称,电脑类型以及型号.按照下图设置即可(名称可以不一样),完成后点击下一步<br><img src="https://img-blog.csdnimg.cn/20200211135545823.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNzczMTY0,size_16,color_FFFFFF,t_70" alt="图四"></p>
<h2 id="4-设置内存大小"><a href="#4-设置内存大小" class="headerlink" title="4.设置内存大小"></a>4.设置内存大小</h2><p>这里根据自身电脑情况来配置吧.<br><br>我电脑比较老了,所以给2G够用就行.<br><img src="https://img-blog.csdnimg.cn/20200211140045179.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNzczMTY0,size_16,color_FFFFFF,t_70" alt="图五"></p>
<h2 id="5-创建虚拟机硬盘"><a href="#5-创建虚拟机硬盘" class="headerlink" title="5.创建虚拟机硬盘"></a>5.创建虚拟机硬盘</h2><p>这里一直点next就行<br><img src="https://img-blog.csdnimg.cn/20200211140326664.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNzczMTY0,size_16,color_FFFFFF,t_70" alt="图六"><br><img src="https://img-blog.csdnimg.cn/20200211140346734.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNzczMTY0,size_16,color_FFFFFF,t_70" alt="图七"><br>到了这里，分匹配虚拟机硬盘。还是那句话，<font color="red" size="5">根据自身需要配置。</font>我只需要进行linux的一些练习，所以20g足矣。<br><br>憨憨同学搞了100G.HHHHHH<br><img src="https://img-blog.csdnimg.cn/20200211140410663.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNzczMTY0,size_16,color_FFFFFF,t_70" alt="图八"></p>
<h1 id="安装并配置Ubuntu"><a href="#安装并配置Ubuntu" class="headerlink" title="安装并配置Ubuntu"></a>安装并配置Ubuntu</h1><h2 id="1-添加虚拟光盘文件"><a href="#1-添加虚拟光盘文件" class="headerlink" title="1.添加虚拟光盘文件"></a>1.添加虚拟光盘文件</h2><p>打开virtual box.设置-存储<br>点击下图标注的”没有光盘”,然后点击最右面的蓝色光盘图标<br><img src="https://img-blog.csdnimg.cn/20200211140929414.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNzczMTY0,size_16,color_FFFFFF,t_70" alt="图九"><br>点击第二个”Choose a disk file”<br>然后选择一开始下载好的镜像文件(xxxxx.iso)<br><img src="https://img-blog.csdnimg.cn/20200211141246861.jpg" alt="图十"><br>成功添加之后就是这样<br><img src="https://img-blog.csdnimg.cn/20200211141222815.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNzczMTY0,size_16,color_FFFFFF,t_70" alt="图十一"></p>
<h2 id="2-安装Ubuntu"><a href="#2-安装Ubuntu" class="headerlink" title="2.安装Ubuntu"></a>2.安装Ubuntu</h2><h3 id="语言设置"><a href="#语言设置" class="headerlink" title="语言设置"></a>语言设置</h3><p>回到软件的初始界面,选中刚刚添加的镜像文件,点击右上角的启动,然后进入下图的界面,双击选择中文<br><img src="https://img-blog.csdnimg.cn/20200211141649435.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNzczMTY0,size_16,color_FFFFFF,t_70" alt="图十二"><br>然后键盘布局，选择英语(美国) - 英语(美国)，点击继续<br><img src="https://img-blog.csdnimg.cn/20200211142022900.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNzczMTY0,size_16,color_FFFFFF,t_70" alt="图十三"></p>
<h3 id="更新和其他软件"><a href="#更新和其他软件" class="headerlink" title="更新和其他软件"></a>更新和其他软件</h3><p>这里<font color="red">不要勾选</font>“安装Ubuntu时下载更新”，太费时间了，点击继续<br><img src="https://img-blog.csdnimg.cn/2020021114220757.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNzczMTY0,size_16,color_FFFFFF,t_70" alt="图十四"></p>
<h3 id="安装类型"><a href="#安装类型" class="headerlink" title="安装类型"></a>安装类型</h3><p>点击安装<br><img src="https://img-blog.csdnimg.cn/20200211142518936.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNzczMTY0,size_16,color_FFFFFF,t_70" alt="图十五"></p>
<h3 id="虚拟机登录信息"><a href="#虚拟机登录信息" class="headerlink" title="虚拟机登录信息"></a>虚拟机登录信息</h3><p>这里大家可以自己输入，然后点击继续。<br>接着就是等待安装结束了（时间可能较长）。<br><img src="https://img-blog.csdnimg.cn/20200211142557614.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNzczMTY0,size_16,color_FFFFFF,t_70" alt="图十六"></p>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>Linux</category>
      </categories>
  </entry>
  <entry>
    <title>我的</title>
    <url>/post/4352.html</url>
    <content><![CDATA[<p>##第一章</p>
<p>内容</p>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>hexo测试</category>
      </categories>
  </entry>
  <entry>
    <title>计算机网络--网络篇</title>
    <url>/post/f61c8a6d.html</url>
    <content><![CDATA[<p>做了一个简单的思维导图</p>
<p><img src="https://img-blog.csdnimg.cn/20200524202823193.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNzczMTY0,size_16,color_FFFFFF,t_70" alt="计算机网络-网络层"></p>
<a id="more"></a>

<p>PDF文件请戳<a href="https://pan.baidu.com/s/1YOdFmrvPbw388tbw-9dPBw" target="_blank" rel="noopener">https://pan.baidu.com/s/1YOdFmrvPbw388tbw-9dPBw</a><br><br>提取码：zcke</p>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>我的第好几篇文章</title>
    <url>/post/51943.html</url>
    <content><![CDATA[<h2 id="第一章"><a href="#第一章" class="headerlink" title="第一章"></a>第一章</h2><h3 id="第一章的第一节"><a href="#第一章的第一节" class="headerlink" title="第一章的第一节"></a>第一章的第一节</h3><p>233333.不知道写什么只是想测试一下</p>
<h3 id="神奇的外链跳转"><a href="#神奇的外链跳转" class="headerlink" title="神奇的外链跳转"></a>神奇的外链跳转</h3><p>点击<a href="https://sex.com" target="_blank" rel="noopener">这里</a> 就能到贤者集中处哦</p>
<a id="more"></a>
<h3 id="代码块"><a href="#代码块" class="headerlink" title="代码块"></a>代码块</h3><figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line">include&lt;iostream&gt;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line"> 	<span class="built_in">cout</span>&lt;&lt;<span class="string">"Hellooooooooooo World!"</span></span><br><span class="line"> 	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>


<h2 id="明天的小目标"><a href="#明天的小目标" class="headerlink" title="明天的小目标"></a>明天的小目标</h2><h3 id="实现博客所有外链-√"><a href="#实现博客所有外链-√" class="headerlink" title="实现博客所有外链(√)"></a>实现博客所有外链(√)</h3><h3 id="学会生成图片"><a href="#学会生成图片" class="headerlink" title="学会生成图片"></a>学会生成图片</h3><p><img src="https://i.loli.net/2020/01/18/HhpXAC5akQ4Fxcy.jpg" alt="嘿嘿"><br>诶嘿,毫无意义的插张图</p>
<h3 id="社会主义核心价值观-√"><a href="#社会主义核心价值观-√" class="headerlink" title="社会主义核心价值观(√)"></a>社会主义核心价值观(√)</h3><h3 id="不蒜子-或者lean-不弄了"><a href="#不蒜子-或者lean-不弄了" class="headerlink" title="不蒜子(或者lean)(不弄了)"></a>不蒜子(或者lean)(不弄了)</h3><h3 id="文章发表更新记录-√"><a href="#文章发表更新记录-√" class="headerlink" title="文章发表更新记录(√)"></a>文章发表更新记录(√)</h3><h3 id="我jio得够了"><a href="#我jio得够了" class="headerlink" title="我jio得够了"></a>我jio得够了</h3><h2 id="哇再加一个"><a href="#哇再加一个" class="headerlink" title="哇再加一个"></a>哇再加一个</h2><p>刚刚发现目录都要隔开一行的,不然默认为正文文本了</p>
<p>下面举个栗子(づ￣3￣)づ<br>形如</p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">## 明天的小目标</span></span><br><span class="line"><span class="comment">### 实现博客所有外链</span></span><br><span class="line"><span class="comment">### 学会生成图片</span></span><br><span class="line"><span class="comment">### 社会主义核心价值观</span></span><br><span class="line"><span class="comment">### 不蒜子(或者lean)</span></span><br><span class="line"><span class="comment">### 文章发表更新记录</span></span><br><span class="line"><span class="comment">### 我jio得够了</span></span><br></pre></td></tr></tbody></table></figure>
<p>是不行滴.必须用空格分隔开.</p>
<p>好了好了.晚安安</p>
<h2 id="还有注意空格"><a href="#还有注意空格" class="headerlink" title="还有注意空格"></a>还有注意空格</h2><h2 id="dnmd"><a href="#dnmd" class="headerlink" title="dnmd"></a>dnmd</h2><script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>hexo测试</category>
      </categories>
  </entry>
  <entry>
    <title>重构真二叉树</title>
    <url>/post/54549.html</url>
    <content><![CDATA[<p>原题是Tsinghua OJ：真二叉树重构(Proper Rebuild)<br><br><a href="https://dsa.cs.tsinghua.edu.cn/oj/course.shtml?courseid=58" target="_blank" rel="noopener">https://dsa.cs.tsinghua.edu.cn/oj/course.shtml?courseid=58</a></p>
<p><font size="5">Description</font><br><br><font size="3"><br>In general, given the preorder traversal sequence and postorder traversal sequence of a binary tree, we cannot determine the binary tree.<br></font><br><a id="more"></a></p>
<p><img src="https://i.loli.net/2020/02/09/TBAio8wzcephqm3.png" alt=""></p>
<p>Figure 1</p>
<p>In Figure 1 for example, although they are two different binary tree, their preorder traversal sequence and postorder traversal sequence are both of the same.</p>
<p>But for one proper binary tree, in which each internal node has two sons, we can uniquely determine it through its given preorder traversal sequence and postorder traversal sequence.</p>
<p>Label n nodes in one binary tree using the integers in [1, n], we would like to output the inorder traversal sequence of a binary tree through its preorder and postorder traversal sequence.</p>
<p><font size="5">Input</font><br><br><font size="3">The 1st line is an integer n, i.e., the number of nodes in one given binary tree,<br>The 2nd and 3rd lines are the given preorder and postorder traversal sequence respectively.</font><br></p>
<p><font size="5">Output</font><br><br><font size="3">The inorder traversal sequence of the given binary tree in one line.</font><br></p>
<p><font size="5">Example</font><br><br>Input</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">5</span><br><span class="line">1 2 4 5 3</span><br><span class="line">4 5 2 3 1</span><br></pre></td></tr></tbody></table></figure>
<p>Output</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">4 2 5 1 3</span><br></pre></td></tr></tbody></table></figure>

<p><font size="5">Restrictions</font><br><br>For 95% of the estimation, 1 &lt;= n &lt;= 1,000,00</p>
<p>For 100% of the estimation, 1 &lt;= n &lt;= 4,000,000</p>
<p>The input sequence is a permutation of {1,2…n}, corresponding to a legal binary tree.</p>
<p>Time: 2 sec</p>
<p>Memory: 256 MB</p>
<p><font size="5">Hints</font></p>
<p><img src="https://i.loli.net/2020/02/09/ToPIS9rKYNxEMuH.png" alt=""></p>
<p>Figure 2</p>
<p>In Figure 2, observe the positions of the left and right children in preorder and postorder traversal sequence.</p>
<p><font size="5"><strong>描述</strong></font><br><br>一般来说，给定二叉树的先序遍历序列和后序遍历序列，并不能确定唯一确定该二叉树。</p>
<p><img src="https://i.loli.net/2020/02/09/TBAio8wzcephqm3.png" alt=""></p>
<p>（图一）</p>
<p>比如图一中的两棵二叉树，虽然它们是不同二叉树，但是它们的先序、后序遍历序列都是相同的。</p>
<p>但是对于“真二叉树”（每个内部节点都有两个孩子的二叉树），给定它的先序、后序遍历序列足以完全确定它的结构。</p>
<p>将二叉树的n个节点用[1, n]内的整数进行编号，输入一棵真二叉树的先序、后序遍历序列，请输出它的中序遍历序列。</p>
<p><font size="5"><strong>描述</strong></font><br><br>第一行为一个整数n，即二叉树中节点的个数。</p>
<p>第二、三行为已知的先序、后序遍历序列。</p>
<p><font size="5"><strong>描述</strong></font><br><br>仅一行，给定真二叉树的中序遍历序列。</p>
<p><font size="5"><strong>描述</strong></font><br><br>见英文题面</p>
<p><font size="5"><strong>描述</strong></font><br><br>对于95%的测例：1 ≤ n ≤ 1,000,000</p>
<p>对于100%的测例：1 ≤ n ≤ 4,000,000</p>
<p>输入的序列是{1,2…n}的排列，且对应于一棵合法的真二叉树</p>
<p>时间：2 sec</p>
<p>空间：256 MB</p>
<p>提示<br><img src="https://i.loli.net/2020/02/09/ToPIS9rKYNxEMuH.png" alt=""></p>
<p>观察左、右孩子在先序、后序遍历序列中的位置</p>
<hr>
<p>　　本来昨天在mooc上看到了邓俊辉老师的数据结构课程，本来只前面讲的（前序|后序）和中序的二叉树重构在课上也听到一些，理解起来不是太难，但是这个，前后序重构真二叉树着实有点傻。<br></p>
<h2 id="重构真二叉树"><a href="#重构真二叉树" class="headerlink" title="重构真二叉树"></a>重构真二叉树</h2><p>　　<strong>真二叉树</strong>(proper binary tree)： 每个节点的度都为<strong>偶数</strong>(2|0)，<br>所以不存在左空右不空的情形，从而无法判断节点位置。根据前后遍历序列,可以重构二叉树，下面借邓俊辉老师的课件插图说明（感兴趣的可点击<a href="https://bilibili.com/video/av49361421/" target="_blank" rel="noopener">这里</a>看一看）：<br><img src="https://i.loli.net/2020/02/09/EM7FyLuraWnBQYi.jpg" alt="真二叉树的前后序遍历"><br>　　如上图，前序遍历的第一个节点必然是根节点，跟随其后的也必然是根节点的左孩子,可以在后序遍历序列中找到它的位置；同理后序遍历序列中最后一个元素必然是根节点，跟随其后的也是根节点的右孩子，可在前序遍历序列中找到位置。<br><br>　　这样，我们就分别划分出了前后遍历序列中左右字数的分界。再通过递归的方法就可以重构二叉树。</p>
<p>　　<del><font size="5">下面是<font color="red">错误代码</font>，还没有改过来。<br></font></del><br>喜大普奔啊，<br>晚上又看了一下网上各位大佬的的方案，总算是解决了。下面是个95分的答案，case20 (runtime error)总是过不去，等有思路了再改吧，</p>
<figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="comment">/**************</span></span><br><span class="line"><span class="comment">7</span></span><br><span class="line"><span class="comment">1 2 4 5 3 6 7</span></span><br><span class="line"><span class="comment">4 5 2 6 7 3 1</span></span><br><span class="line"><span class="comment">**************/</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">BinNode</span></span></span><br><span class="line"><span class="class">{</span></span><br><span class="line">    <span class="keyword">int</span> data;<span class="comment">//数据</span></span><br><span class="line">    BinNode *lc;<span class="comment">//左孩子</span></span><br><span class="line">    BinNode *rc;<span class="comment">//右孩子</span></span><br><span class="line">    BinNode() : lc ( <span class="literal">NULL</span> ), rc ( <span class="literal">NULL</span> ) {}</span><br><span class="line">    BinNode ( <span class="keyword">int</span> _data ) : data ( _data ), lc ( <span class="literal">NULL</span> ), rc ( <span class="literal">NULL</span> ) {}</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function">BinNode* <span class="title">rebuild</span> <span class="params">( <span class="keyword">int</span> length, <span class="keyword">int</span> *pre, <span class="keyword">int</span> *post )</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	BinNode* root = <span class="keyword">new</span> BinNode;<span class="comment">//创建一个新节点</span></span><br><span class="line">    root-&gt;data = pre[<span class="number">0</span>];<span class="comment">//以新节点为根,数据域为pre序列的第一个数</span></span><br><span class="line">    <span class="keyword">if</span> (length &lt; <span class="number">2</span>)<span class="comment">//递归结束</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> mid_left;<span class="comment">//记录左子树根节点在postOrder中的位置</span></span><br><span class="line">    <span class="keyword">for</span> ( mid_left = <span class="number">0</span>; mid_left &lt; length; mid_left++ )</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">if</span> ( pre[<span class="number">1</span>] == post[mid_left] )</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">//左子树节点个数为mid_left+1</span></span><br><span class="line">    <span class="comment">//右子树节点个数为length-1-(mid_left+1)</span></span><br><span class="line">    root-&gt;lc = rebuild ( mid_left + <span class="number">1</span>, pre + <span class="number">1</span>, post );</span><br><span class="line">    root-&gt;rc = rebuild ( length - mid_left - <span class="number">2</span>, pre + mid_left + <span class="number">2</span>, post + mid_left + <span class="number">1</span> );</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//中序遍历</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">inOrder</span><span class="params">(BinNode *root)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">if</span> (root-&gt;lc)</span><br><span class="line">        inOrder ( root-&gt;lc );</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;root-&gt;data;</span><br><span class="line">    <span class="keyword">if</span> (root-&gt;rc)</span><br><span class="line">        inOrder ( root-&gt;rc );</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">int</span> length;<span class="comment">//节点个数</span></span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; length;</span><br><span class="line">    <span class="keyword">int</span> pre[length], post[length];</span><br><span class="line">    <span class="keyword">for</span> ( <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; i++ )</span><br><span class="line">    {</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; pre[i];</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">for</span> ( <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; i++ )</span><br><span class="line">    {</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; post[i];</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    BinNode* root;</span><br><span class="line">    root = rebuild ( length, pre, post );</span><br><span class="line"></span><br><span class="line">    inOrder ( root );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>树</tag>
      </tags>
  </entry>
  <entry>
    <title>记录一下自己的蠢事</title>
    <url>/post/21442.html</url>
    <content><![CDATA[<p>先看一下原题:<br>pta 7-2<br>给定一棵二叉树的中序遍历和前序遍历，请你先将树做个镜面反转，再输出反转后的层序遍历的序列。所谓镜面反转，是指将所有非叶结点的左右孩子对换。这里假设键值都是互不相等的正整数。<a id="more"></a></p>
<p>输入格式：<br>输入第一行给出一个正整数N（≤30），是二叉树中结点的个数。第二行给出其中序遍历序列。第三行给出其前序遍历序列。数字间以空格分隔。</p>
<p>输出格式：<br>在一行中输出该树反转后的层序遍历的序列。数字间以1个空格分隔，行首尾不得有多余空格。</p>
<p>输入样例：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">7</span><br><span class="line">1 2 3 4 5 6 7</span><br><span class="line">4 1 3 2 6 5 7</span><br></pre></td></tr></tbody></table></figure>


<p>输出样例：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">4 6 1 7 5 3 2</span><br></pre></td></tr></tbody></table></figure>

<p>题目并不难,buuuuuuuuuuut 我蠢啊<br><br>用char数组存储了前中遍历序列,<br>然后把值赋给了int类型的data<br><br>debug半天特别懵<br>唉,浪费我上分的时间了<br><br>下面给出AC代码</p>
<figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">BinNode</span></span></span><br><span class="line"><span class="class">{</span></span><br><span class="line">    <span class="keyword">int</span> data;</span><br><span class="line">    BinNode* lc;</span><br><span class="line">    BinNode* rc;</span><br><span class="line">    BinNode() : lc ( <span class="literal">NULL</span> ), rc ( <span class="literal">NULL</span> ) {}</span><br><span class="line">    BinNode ( <span class="keyword">int</span> _data ) : data ( _data ), lc ( <span class="literal">NULL</span> ), rc ( <span class="literal">NULL</span> ) {}</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function">BinNode* <span class="title">rebuild</span> <span class="params">( <span class="keyword">int</span> length, <span class="keyword">int</span> *pre, <span class="keyword">int</span>*in )</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">if</span> ( length == <span class="number">0</span> )</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    BinNode *r = <span class="keyword">new</span> BinNode;</span><br><span class="line">    r-&gt;data = pre[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt; length; i ++ )</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">if</span> ( pre[<span class="number">0</span>] == in[i] )</span><br><span class="line">        {</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">//cout&lt;&lt;r-&gt;data&lt;&lt;" ";</span></span><br><span class="line">    r-&gt;lc = rebuild ( i, pre + <span class="number">1</span>, in );</span><br><span class="line">    r-&gt;rc = rebuild ( length - i - <span class="number">1</span>, pre + i + <span class="number">1</span>, in + i + <span class="number">1</span> );</span><br><span class="line">    <span class="keyword">return</span> r;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">levelTran</span> <span class="params">( BinNode* root )</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="built_in">queue</span>&lt;BinNode* &gt; q;</span><br><span class="line">    q.push ( root );</span><br><span class="line">    <span class="keyword">while</span> ( !q.empty() )</span><br><span class="line">    {</span><br><span class="line">        BinNode* temp = q.front();</span><br><span class="line">        q.pop();</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; temp-&gt;data&lt;&lt;<span class="string">" "</span>;</span><br><span class="line">        <span class="keyword">if</span> ( temp-&gt;rc )</span><br><span class="line">            q.push ( temp-&gt;rc );</span><br><span class="line">        <span class="keyword">if</span> ( temp-&gt;lc )</span><br><span class="line">            q.push ( temp-&gt;lc );</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">int</span> length;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; length;</span><br><span class="line">    <span class="keyword">if</span> ( length &gt; <span class="number">30</span> )</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> in[length];</span><br><span class="line">    <span class="keyword">int</span> pre[length];</span><br><span class="line">    <span class="keyword">for</span> ( <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; i++ )</span><br><span class="line">    {</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; in[i];</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">for</span> ( <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; i++ )</span><br><span class="line">    {</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; pre[i];</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    BinNode* root;</span><br><span class="line">    root = rebuild ( length, pre, in );</span><br><span class="line"></span><br><span class="line">    levelTran(root);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>数据结构</category>
        <category>二叉树</category>
      </categories>
  </entry>
  <entry>
    <title>MySQL（二）</title>
    <url>/post/66a19f30.html</url>
    <content><![CDATA[<h1 id="MySQL（二"><a href="#MySQL（二" class="headerlink" title="MySQL（二)"></a>MySQL（二)</h1><h2 id="联结"><a href="#联结" class="headerlink" title="联结"></a>联结</h2><p><strong>外键</strong>，它是表中的一列，也是其他表的主键，定义里两个表之间的关系。</p>
<p><font style="color:red" size="5">Q：如果数据存储在多个表中，怎样用单条SELECT语句检索出数据？</font></p>
<p><font style="color:green" size="5">A：使用联结。简单地说，联结是一种机制，用来在一条SELECT语句中关联表，因此称之为联结。使用特殊的语法，可以联结多个表返回一组输出，联结在运行时关联表中正确的行。</font> <a id="more"></a></p>
<p><strong>注：联结并不实际存在于数据库中，只是一种表现形式。</strong></p>
<p>如：</p>
<figure class="highlight sql"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> employees.first_name, jobs.job_title</span><br><span class="line"><span class="keyword">FROM</span> employees, jobs</span><br><span class="line"><span class="keyword">WHERE</span> employees.job_id = jobs.job_id;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- job_id作为employees的外键</span></span><br><span class="line"><span class="comment">-- 要查询的·名·和·工作职称·分别是两个表中的列</span></span><br></pre></td></tr></tbody></table></figure>

<p>若没有where子句也就是<strong>联结条件</strong>，检索出的结果是，第一个表的每一行和第二个表的每一行配对，得到行的数目将是第一个表中的行数乘以第二个表中的行数。这也叫做<strong>笛卡尔积</strong>。</p>
<p><strong>内部联结</strong></p>
<p>上面所写的根据外键和另一个表的主键进行匹配的方式叫做<strong>等值联结</strong>，也叫<strong>内部联结</strong>，他还有另一种方式表达：</p>
<figure class="highlight sql"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> employees.first_name, jobs.job_title</span><br><span class="line"><span class="keyword">FROM</span> employees <span class="keyword">INNER</span> <span class="keyword">JOIN</span> jobs</span><br><span class="line"><span class="keyword">ON</span> employees.job_id = jobs.job_id;</span><br></pre></td></tr></tbody></table></figure>

<p>就是FROM子句进行了变更，以及用ON替换了WHERE语句。</p>
<p>###　联结多个表</p>
<p>SQL中可以联结多个表，连接条件在WHERE从句中，使用<strong><em>AND</em></strong>连接。</p>
<p>若连接三个表，则至少需要两个联结条件。</p>
<p>如：</p>
<figure class="highlight sql"><table><tbody><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<p><strong>注：联结耗费资源！！！</strong></p>
<h3 id="高级联结"><a href="#高级联结" class="headerlink" title="高级联结"></a>高级联结</h3><p>对被联结的表使用表别名和聚集函数。</p>
<figure class="highlight sql"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> e.first_name, jb.job_title</span><br><span class="line"><span class="keyword">FROM</span> employees <span class="keyword">AS</span> e, jobs <span class="keyword">AS</span> jb </span><br><span class="line"><span class="keyword">WHERE</span> e.job_id = jb.job_id;</span><br><span class="line"><span class="comment">-- 使用了表名缩写</span></span><br></pre></td></tr></tbody></table></figure>

<ol>
<li><p>自连接</p>
</li>
<li><p><strong>左连接</strong>，LEFT JOIN；</p>
<p>是返回左表和右表中关联字段相等的记录；</p>
<p>就是，返回左表得到全部，以及右表中连接字段相等的记录，不相等的记为空。</p>
</li>
<li><p><strong>右连接</strong>参考左连接。</p>
</li>
<li><p><strong>交叉连接</strong>，CROSS JOIN，就是笛卡尔积。</p>
</li>
</ol>
<h2 id="组合查询"><a href="#组合查询" class="headerlink" title="组合查询"></a>组合查询</h2><p>执行多个查询（多条SELECT语句），并将结果作为单个查询结果集返回。这些组合查询通常称为并（union）或复合查询</p>
<p>（compound query）。</p>
<p>使用<strong>UNION</strong>关键字将查询结果组合。</p>
<p>每个SELECT语句之间由UNION连接，并且UNION两侧的SELECT语句必须具有<strong>相同的列（顺序可以不同）</strong>；</p>
<p>UNION在组合两个查询结果时，会默认把重复数据清理只保留一个，若要显示全部需在后面加上ALL；</p>
<p>UNION连接的查询语句中，只能有一个ORDER BY，即使两个ORDER BY一样。</p>
<p>如，</p>
<figure class="highlight sql"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> vend_id,prod_id,prod_price</span><br><span class="line"><span class="keyword">FROM</span> products</span><br><span class="line"><span class="keyword">WHERE</span> prod_price &lt;= <span class="number">5</span></span><br><span class="line"><span class="keyword">UNION</span> [<span class="keyword">ALL</span>]</span><br><span class="line"><span class="keyword">SELECT</span> vend_id, prod_id, prod_price</span><br><span class="line"><span class="keyword">FROM</span> products</span><br><span class="line"><span class="keyword">WHERE</span> vend_id <span class="keyword">IN</span> (<span class="number">1001</span>, <span class="number">1002</span>)</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> vend_id, prod_id;</span><br><span class="line"><span class="comment">-- 查找价格&lt;=5 以及 1001，1002商家提供的商品信息</span></span><br></pre></td></tr></tbody></table></figure>

<p>、</p>
<h2 id="全文本查询"><a href="#全文本查询" class="headerlink" title="全文本查询"></a>全文本查询</h2><p>通配符、正则表达式都尝试对数据库中所有行进行匹配，<strong>耗时</strong>，并且很难精确搜索。</p>
<p>使用时，<strong>Match()</strong>指定被搜索的列，<strong>Against()</strong>指定要使用的搜索表达式；</p>
<p>数据是索引的，<strong>很快</strong>；默认<strong>不区分大小写</strong>；</p>
<p>排除等级为0（不含待搜索表达式）的行；结果以等级（含待搜索表达式的个数）降序排列。</p>
<figure class="highlight sql"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> note_text</span><br><span class="line"><span class="keyword">FROM</span> productnotes</span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">MATCH</span>(note_text) AGAINST( <span class="string">'rabbit'</span>);</span><br><span class="line"><span class="comment">-- 搜索note_text列中rabbit</span></span><br></pre></td></tr></tbody></table></figure>

<p><strong>查询扩展</strong></p>
<p>利用查询扩展，能找出可能相关的结果，即使它们并不精确包含所查找的词。</p>
<p>使用时，在AGAINST里，待搜索表达式后面加上<strong>WITH QUERY EXPANSION</strong>。</p>
<p><strong>布尔文本搜索</strong></p>
<p>搜索<strong>慢</strong>，可提供以下功能：</p>
<p><img src="https://gitee.com/man-ljw/PicBed/raw/master/QQ%E6%88%AA%E5%9B%BE20210706164928.jpg" alt=""></p>
<p><img src="https://gitee.com/man-ljw/PicBed/raw/master/QQ%E6%88%AA%E5%9B%BE20210706170055.jpg" alt=""></p>
<p>如：</p>
<figure class="highlight sql"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> note_text</span><br><span class="line"><span class="keyword">FROM</span> productnotes</span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">MATCH</span>(note_text) AGAINST( <span class="string">'+rabbit -bait'</span> <span class="keyword">IN</span> <span class="built_in">BOOLEAN</span> <span class="keyword">MODE</span>);</span><br><span class="line"><span class="comment">-- note_text中，含有rabbit但不含bait的数据</span></span><br></pre></td></tr></tbody></table></figure>



<h1 id="以上源于《MySQL必知必会》"><a href="#以上源于《MySQL必知必会》" class="headerlink" title="以上源于《MySQL必知必会》"></a>以上源于《MySQL必知必会》</h1><script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL（三）</title>
    <url>/post/f07c622d.html</url>
    <content><![CDATA[<h1 id="插入数据"><a href="#插入数据" class="headerlink" title="插入数据"></a>插入数据</h1><h2 id="插入单行"><a href="#插入单行" class="headerlink" title="插入单行"></a>插入单行</h2><figure class="highlight sql"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">-- 采用这种方式向表中添加数据，必须 按表中各字段的顺序 为每一个字段提供一个值，如果没有可以赋值null</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> 表名</span><br><span class="line"><span class="keyword">VALUES</span>(value1,</span><br><span class="line">       value2,</span><br><span class="line">       ·</span><br><span class="line">       ·</span><br><span class="line">       ·</span><br><span class="line">);</span><br></pre></td></tr></tbody></table></figure>
<a id="more"></a>
<p>由于上面这种方式严格要求赋值顺序和表中字段顺序一致，所以有了下面这种方式：</p>
<figure class="highlight sql"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">--说明赋值顺序</span></span><br><span class="line"><span class="keyword">INSERT</span> [<span class="keyword">LOW_PRIORITY</span>] <span class="keyword">INTO</span> 表名(</span><br><span class="line">字段<span class="number">1</span>，</span><br><span class="line">字段<span class="number">2</span>,</span><br><span class="line">·</span><br><span class="line">·</span><br><span class="line">·) </span><br><span class="line"><span class="keyword">VALUES</span>(value1,</span><br><span class="line">       value2,</span><br><span class="line">       ·</span><br><span class="line">       ·</span><br><span class="line">       ·</span><br><span class="line">);</span><br></pre></td></tr></tbody></table></figure>

<p>由于INSERT可能很耗时，进而会影响后面的SELECT语句，所以加上<code>LOW_PRIORITY</code><strong>降低</strong>INSERT的<strong>优先级</strong>。</p>
<h2 id="插入多行"><a href="#插入多行" class="headerlink" title="插入多行"></a>插入多行</h2><figure class="highlight sql"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> [<span class="keyword">LOW_PRIORITY</span>] <span class="keyword">INTO</span> 表名(</span><br><span class="line">字段<span class="number">1</span>，</span><br><span class="line">字段<span class="number">2</span>,</span><br><span class="line">·</span><br><span class="line">·</span><br><span class="line">·) </span><br><span class="line"><span class="keyword">VALUES</span>(value1,</span><br><span class="line">       value2,</span><br><span class="line">       ·</span><br><span class="line">       ·</span><br><span class="line">       ·</span><br><span class="line">),</span><br><span class="line"><span class="keyword">VALUES</span>(value1,</span><br><span class="line">       value2,</span><br><span class="line">       ·</span><br><span class="line">       ·</span><br><span class="line">       ·</span><br><span class="line">);</span><br></pre></td></tr></tbody></table></figure>

<p><strong>单条SELECT插入多行数据比多条SELECT依次插入单行数据快。</strong></p>
<h2 id="插入检索出的数据"><a href="#插入检索出的数据" class="headerlink" title="插入检索出的数据"></a>插入检索出的数据</h2><p>如下，将表2的指定列的数据添加到表1里。</p>
<p><strong>不要求</strong>字段对应相同，因为INSERT要的只是SELECT查询返回的值。</p>
<figure class="highlight sql"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> 表名<span class="number">1</span>(</span><br><span class="line">字段<span class="number">1</span>，</span><br><span class="line">字段<span class="number">2</span>,</span><br><span class="line">·</span><br><span class="line">·</span><br><span class="line">·) </span><br><span class="line"><span class="keyword">SELECT</span>(</span><br><span class="line">字段<span class="number">1</span>，</span><br><span class="line">字段<span class="number">2</span>,</span><br><span class="line">·</span><br><span class="line">·</span><br><span class="line">·) </span><br><span class="line"><span class="keyword">FROM</span> 表名<span class="number">2</span>;</span><br></pre></td></tr></tbody></table></figure>



<h1 id="更新数据"><a href="#更新数据" class="headerlink" title="更新数据"></a>更新数据</h1><p>一般格式如下：</p>
<figure class="highlight sql"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> 表名</span><br><span class="line"><span class="keyword">SET</span> 字段<span class="number">1</span> = 值</span><br><span class="line">	[,字段<span class="number">2</span> = 值</span><br><span class="line">     , 字段<span class="number">3</span> = 值]</span><br><span class="line"><span class="keyword">WHERE</span> 更新条件</span><br></pre></td></tr></tbody></table></figure>



<h1 id="删除数据"><a href="#删除数据" class="headerlink" title="删除数据"></a>删除数据</h1><p>一般格式如下：</p>
<figure class="highlight sql"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> 表名</span><br><span class="line"><span class="keyword">WHERE</span> 删除条件;</span><br></pre></td></tr></tbody></table></figure>

<p>DELETE只能删除行。若要删除表中所有行，使用<code>TRUNCATE 表名</code>效率更高，因为TRUNCATE是删除原表并新建一个同名表。</p>
<h1 id="创建表"><a href="#创建表" class="headerlink" title="创建表"></a>创建表</h1><p>控制字段用于指明字段是否可以为空(NULL或NOT NULL)、增长方式(AUTO_INCREMENT)等。</p>
<p>在最后声明作为主键的字段，主键中不能有NULL。</p>
<figure class="highlight sql"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="keyword">IF</span> <span class="keyword">NOT</span> <span class="keyword">EXISTS</span> 表名(</span><br><span class="line">字段<span class="number">1</span> 类型 控制字段<span class="number">1</span> 控制字段<span class="number">2</span>,</span><br><span class="line">    ·</span><br><span class="line">    ·</span><br><span class="line">    ·</span><br><span class="line"> PRIMARY <span class="keyword">KEY</span>(字段<span class="number">1</span>， 字段<span class="number">2</span>)</span><br><span class="line">)<span class="keyword">ENGINE</span> = <span class="keyword">InnoDB</span> <span class="comment">--指明引擎类型，默认MyISAM</span></span><br></pre></td></tr></tbody></table></figure>

<p>如果主键设为自动增长后，自己INSERT一条数据指明了主键取值m，那么下次INSERT数据默认的主键取值从m+1开始。</p>
<p>可以通过<code>SELECT LAST_INSERT_ID()</code>查看上一次的AUTO_INCREMENT值。</p>
<p>控制字段还可选<strong>指定默认值</strong>，通过<code>DEFAULT 默认值</code>，</p>
<h1 id="更新表"><a href="#更新表" class="headerlink" title="更新表"></a>更新表</h1><h2 id="删除列"><a href="#删除列" class="headerlink" title="删除列"></a>删除列</h2><figure class="highlight sql"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> 表名 </span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">COLUMN</span> 列名;</span><br></pre></td></tr></tbody></table></figure>

<h2 id="添加列"><a href="#添加列" class="headerlink" title="添加列"></a>添加列</h2><figure class="highlight sql"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> 表名</span><br><span class="line"><span class="keyword">ADD</span> 列名 类型;</span><br></pre></td></tr></tbody></table></figure>

<h2 id="添加外键"><a href="#添加外键" class="headerlink" title="添加外键"></a>添加外键</h2><figure class="highlight sql"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> 表名</span><br><span class="line"><span class="keyword">ADD</span> <span class="keyword">CONSTRAINTS</span> 约束名</span><br><span class="line"><span class="keyword">FOREIGN</span> <span class="keyword">KEY</span> (做外键的字段名) </span><br><span class="line">PREFERENCES 表名<span class="number">2</span> (改表对应的主键列名);</span><br></pre></td></tr></tbody></table></figure>

<h1 id="删除表"><a href="#删除表" class="headerlink" title="删除表"></a>删除表</h1><figure class="highlight sql"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> 表名;</span><br></pre></td></tr></tbody></table></figure>

<h1 id="重命名表"><a href="#重命名表" class="headerlink" title="重命名表"></a>重命名表</h1><figure class="highlight sql"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">RENAME</span> <span class="keyword">TABLE</span> 原表名 <span class="keyword">TO</span> 新表名;</span><br></pre></td></tr></tbody></table></figure>

<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL（四）</title>
    <url>/post/47517b48.html</url>
    <content><![CDATA[<h1 id="视图"><a href="#视图" class="headerlink" title="视图"></a>视图</h1><p>视图是<strong>虚拟</strong>的表。与包含数据的表不一样，视图只包含使用时动态检索数据的查询。不包含表中应该有的任何列或数据，它包含的是一个SQL查询。</p>
<p>可以对视图执行SELECT操作，过滤和排序数据，将视图联结到其他视图或表，甚至能添加和更新数据</p>
<a id="more"></a>

<p>对视图增加或删除行，实际上是对其基表增加或删除行。</p>
<p>并非所有视图都是可更新的。</p>
<p>视图<strong>不能索引</strong>。</p>
<h2 id="创建视图实例"><a href="#创建视图实例" class="headerlink" title="创建视图实例"></a>创建视图实例</h2><figure class="highlight sql"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">VIEW</span> product_customers <span class="keyword">AS</span></span><br><span class="line"><span class="keyword">SELECT</span> cust_name, cust_contact, prod_id</span><br><span class="line"><span class="keyword">FROM</span> customers, orders, orderitems</span><br><span class="line"><span class="keyword">WHERE</span> customers.cust_id = orders.cust_id</span><br><span class="line"><span class="keyword">AND</span> orderitems.order_num = orders. order_num ;</span><br></pre></td></tr></tbody></table></figure>

<p>作用：<strong>重新格式化</strong>，<strong>过滤表中不想要的数据</strong></p>
<h1 id="存储过程"><a href="#存储过程" class="headerlink" title="存储过程"></a>存储过程</h1><h2 id="调用存储过程"><a href="#调用存储过程" class="headerlink" title="调用存储过程"></a>调用存储过程</h2><figure class="highlight sql"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">CALL</span> 存储过程名(参数<span class="number">1</span>,</span><br><span class="line">          参数<span class="number">2</span></span><br><span class="line">          ·</span><br><span class="line">          ·</span><br><span class="line">          ·);</span><br></pre></td></tr></tbody></table></figure>

<h2 id="创建存储过程"><a href="#创建存储过程" class="headerlink" title="创建存储过程"></a>创建存储过程</h2><figure class="highlight sql"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">PROCEDURE</span> 存储过程名([<span class="keyword">OUT</span> 参数<span class="number">1</span> 类型,</span><br><span class="line">                       <span class="keyword">IN</span> 参数<span class="number">2</span> 类型···])</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">	<span class="keyword">SELECT</span> 字段</span><br><span class="line">    <span class="keyword">INTO</span> 参数</span><br><span class="line">	<span class="keyword">FROM</span> 表名;</span><br><span class="line">	其他操作 </span><br><span class="line"><span class="keyword">END</span>;</span><br></pre></td></tr></tbody></table></figure>

<h2 id="删除存储过程"><a href="#删除存储过程" class="headerlink" title="删除存储过程"></a>删除存储过程</h2><figure class="highlight sql"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">PROCEDURE</span> 存储过程名();</span><br></pre></td></tr></tbody></table></figure>

<p><strong>注：</strong>所有MySQL变量都必须以@开始。</p>
<p>以下是两个书上的实例:</p>
<figure class="highlight sql"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">-- 创建存储过程</span></span><br><span class="line"><span class="comment">-- 有三个输出参数</span></span><br><span class="line">DELIMITER $$</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span></span><br><span class="line">    <span class="keyword">PROCEDURE</span> <span class="string">`test`</span>.<span class="string">`hhh`</span>(<span class="keyword">OUT</span> pl <span class="built_in">DECIMAL</span>(<span class="number">8</span>,<span class="number">2</span>),</span><br><span class="line">	<span class="keyword">OUT</span> ph <span class="built_in">DECIMAL</span>(<span class="number">8</span>,<span class="number">2</span>),</span><br><span class="line">	<span class="keyword">OUT</span> pa <span class="built_in">DECIMAL</span>(<span class="number">8</span>,<span class="number">2</span>)</span><br><span class="line">	)</span><br><span class="line">	<span class="keyword">BEGIN</span></span><br><span class="line">	<span class="keyword">SELECT</span> <span class="keyword">MIN</span>(prod_price)</span><br><span class="line">	<span class="keyword">INTO</span> pl</span><br><span class="line">	<span class="keyword">FROM</span> products;</span><br><span class="line">	<span class="keyword">SELECT</span> <span class="keyword">MAX</span>(prod_price)</span><br><span class="line">	<span class="keyword">INTO</span> ph</span><br><span class="line">	<span class="keyword">FROM</span> products;</span><br><span class="line">	<span class="keyword">SELECT</span> <span class="keyword">AVG</span>(prod_price)</span><br><span class="line">	<span class="keyword">INTO</span> pa</span><br><span class="line">	<span class="keyword">FROM</span> products;</span><br><span class="line">	<span class="keyword">END</span>$$</span><br><span class="line"></span><br><span class="line">DELIMITER ;</span><br><span class="line"></span><br><span class="line"><span class="comment">------------------------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="comment">--调用存储过程</span></span><br><span class="line"><span class="keyword">CALL</span> hhh(@a, @b, @c); <span class="comment">--将结果返回给abc桑变量，不过不会直接显示，需要SELECT查询。</span></span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight sql"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">--创建存储方法owo</span></span><br><span class="line"><span class="comment">--有两个参数，一个输入，一个输出</span></span><br><span class="line">DELIMITER $$</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span></span><br><span class="line">    <span class="comment">/*[DEFINER = { user | CURRENT_USER }]*/</span></span><br><span class="line">    <span class="keyword">PROCEDURE</span> <span class="string">`test`</span>.<span class="string">`owo`</span>(</span><br><span class="line">    <span class="keyword">IN</span> onumber <span class="built_in">INT</span>,</span><br><span class="line">    <span class="keyword">OUT</span> ototal  <span class="built_in">DECIMAL</span>(<span class="number">8</span>,<span class="number">2</span>)</span><br><span class="line">    )</span><br><span class="line">    <span class="keyword">BEGIN</span></span><br><span class="line">    <span class="keyword">SELECT</span> <span class="keyword">SUM</span>(item_price*quantity)</span><br><span class="line">    <span class="keyword">FROM</span> oderitems</span><br><span class="line">    <span class="keyword">WHERE</span> order_num = onumber</span><br><span class="line">    <span class="keyword">INTO</span> ototal;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">END</span>$$</span><br><span class="line"></span><br><span class="line">DELIMITER ;</span><br><span class="line"></span><br><span class="line"><span class="comment">--调用owo</span></span><br><span class="line"><span class="keyword">CALL</span> owo(<span class="number">20005</span>, @total); <span class="comment">--20005作为输出，@total接受输出</span></span><br><span class="line"><span class="keyword">SELECT</span> @total</span><br></pre></td></tr></tbody></table></figure>

<p>还可以使用DECLARE，IF，THEN等完成更强大的存储过程。</p>
<p><font size="7">待补</font></p>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL（五）</title>
    <url>/post/28cfbe0f.html</url>
    <content><![CDATA[<h1 id="游标"><a href="#游标" class="headerlink" title="游标"></a>游标</h1><p>游标（cursor）是一个存储在MySQL服务器上的数据库查询，它不是一条SELECT语句，而是被该语句检索出来的结果集。</p>
<p>有时，需要在检索出来的行中前进或后退一行或多行。这就是使用游标的原因。</p>
<p>MySQL中游标只能用于存储过程。</p>
<a id="more"></a>

<h2 id="声明游标"><a href="#声明游标" class="headerlink" title="声明游标"></a>声明游标</h2><figure class="highlight sql"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">PROCEDURE</span> 存储过程名()</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">	<span class="keyword">DECLARE</span> 游标名 <span class="keyword">CURSOR</span></span><br><span class="line">	<span class="keyword">FOR</span></span><br><span class="line">	<span class="keyword">SELECT</span> 列名</span><br><span class="line">	<span class="keyword">FROM</span> 表名</span><br><span class="line"><span class="keyword">END</span>;</span><br></pre></td></tr></tbody></table></figure>



<h2 id="打开游标和关闭游标"><a href="#打开游标和关闭游标" class="headerlink" title="打开游标和关闭游标"></a>打开游标和关闭游标</h2><figure class="highlight sql"><table><tbody><tr><td class="code"><pre><span class="line">OPEN 游标名;</span><br><span class="line"></span><br><span class="line">CLOSE 游标名;</span><br><span class="line"><span class="comment">-- 如果你不明确关闭游标，MySQL将会在到达END语句时自动关闭它。</span></span><br></pre></td></tr></tbody></table></figure>



<h2 id="使用游标数据"><a href="#使用游标数据" class="headerlink" title="使用游标数据"></a>使用游标数据</h2><p>使用游标数据的前提是，已经打开了游标，然后使用FETCH语句逐行访问。</p>
<figure class="highlight sql"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">PROCEDURE</span> processorders(oBEGIN</span><br><span class="line"><span class="comment">-- Declare local variablesDECLARE o INT;</span></span><br><span class="line"><span class="comment">-- Declare the cursor</span></span><br><span class="line"><span class="keyword">DECLARE</span> ordernumbers CURSORFOR</span><br><span class="line"><span class="keyword">SELECT</span> order_num <span class="keyword">FROM</span> orders;</span><br><span class="line"><span class="comment">-- open the cursor</span></span><br><span class="line">OPEN ordernumbers;</span><br><span class="line"><span class="comment">-- Get order number</span></span><br><span class="line">FETCH ordernumbers INTO o ;</span><br><span class="line"><span class="comment">-- Close the cursor</span></span><br><span class="line">CLOSE ordernumbers;</span><br><span class="line"><span class="keyword">END</span>;</span><br></pre></td></tr></tbody></table></figure>

<p><font size="7">待补</font></p>
<h1 id="触发器"><a href="#触发器" class="headerlink" title="触发器"></a>触发器</h1><p>在某个表发生更改时<strong>自动处理</strong>，这确切地说就是触发器。</p>
<p>触发器值响应<strong>DELETE，UPDATE，INSERT</strong>这三种操作，可以选择在这三种操作之前或之后响应，也就是说每个表至多有六个触发器。</p>
<p>触发器名必须在每个<strong>表</strong>中唯一，而不是整个数据库。</p>
<p>只有<strong>表</strong>才支持触发器，视图不行。</p>
<h2 id="创建触发器"><a href="#创建触发器" class="headerlink" title="创建触发器"></a>创建触发器</h2><figure class="highlight sql"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TRIGGER</span> 触发器名 <span class="keyword">BEFORE</span>/<span class="keyword">AFTER</span></span><br><span class="line"><span class="keyword">INSERT</span>/<span class="keyword">UPDATE</span>/<span class="keyword">DELETE</span> <span class="keyword">ON</span> 表名</span><br><span class="line">[<span class="keyword">FOR</span> <span class="keyword">EACH</span> <span class="keyword">ROW</span>] 响应动作</span><br></pre></td></tr></tbody></table></figure>



<h2 id="删除触发器"><a href="#删除触发器" class="headerlink" title="删除触发器"></a>删除触发器</h2><figure class="highlight sql"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">TRIGGER</span> 触发器名;</span><br></pre></td></tr></tbody></table></figure>



<p><strong>INSERT触发器</strong>：</p>
<p>​    在INSERT触发器内，可以引用一个名为<strong>NEW</strong>的的虚拟表访问被插入的行；</p>
<p>​    在BEFOREINSERT触发器中，NEW中的值可以被改变；</p>
<p><strong>DELETE触发器</strong>：</p>
<p>​     在DELETE触发器内，可以引用一个名为<strong>OLD</strong>的虚拟表访问被删除的行；</p>
<p>​    OLD中的值不可更改。</p>
<p><strong>UPDATE触发器：</strong></p>
<p>​    在UPDATE触发器内，可以用<strong>OLD</strong>表访问更改前的值，使用<strong>NEW</strong>表访问更改后的值；</p>
<p>​    NEW中的值可以被改变；OLD中的值不可更改。</p>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL（一）</title>
    <url>/post/226c5d31.html</url>
    <content><![CDATA[<h1 id="MySQL（一）"><a href="#MySQL（一）" class="headerlink" title="MySQL（一）"></a>MySQL（一）</h1><h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><p><strong>登录mysql</strong></p>
<figure class="highlight sql"><table><tbody><tr><td class="code"><pre><span class="line">mysql [-h 主机名 -P 端口号] -u root -p</span><br></pre></td></tr></tbody></table></figure>

<p>MySQL中，每条命令以<code>;</code>作为结束符。<a id="more"></a></p>
<p><strong>列出数据库</strong></p>
<figure class="highlight sql"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> <span class="keyword">DATABASES</span>;</span><br></pre></td></tr></tbody></table></figure>

<p><strong>选中要使用的数据库</strong></p>
<figure class="highlight sql"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> 数据库名;</span><br></pre></td></tr></tbody></table></figure>

<p><strong>显示当前选择的数据库内可用表的列表。</strong></p>
<figure class="highlight sql"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">show</span> <span class="keyword">tables</span> <span class="keyword">from</span> 表名;</span><br></pre></td></tr></tbody></table></figure>

<p><strong>返回指定表的个字段信息</strong></p>
<figure class="highlight sql"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">show</span> <span class="keyword">columns</span> <span class="keyword">from</span> 表名;</span><br><span class="line">或</span><br><span class="line"><span class="keyword">describe</span> 表名;</span><br></pre></td></tr></tbody></table></figure>

<p><strong>来显示服务器错误或警告消息</strong></p>
<figure class="highlight sql"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">show</span> <span class="keyword">errors</span>;</span><br><span class="line"><span class="keyword">show</span> <span class="keyword">warnings</span>;</span><br></pre></td></tr></tbody></table></figure>

<p><strong>建表</strong></p>
<figure class="highlight sql"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> 表名(</span><br><span class="line">	属性<span class="number">1</span> 类型,</span><br><span class="line">	属性<span class="number">2</span> 类型,</span><br><span class="line">);</span><br></pre></td></tr></tbody></table></figure>



<p><strong>增删改查</strong></p>
<figure class="highlight sql"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> 表名 <span class="keyword">values</span>(value1, value2); <span class="comment">-- 增加数据</span></span><br><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> 表名 <span class="keyword">where</span> 删除条件; <span class="comment">-- 删除表中项目</span></span><br><span class="line"><span class="keyword">update</span> 表名 <span class="keyword">set</span> 属性=<span class="keyword">value</span> <span class="keyword">where</span> 更新条件; <span class="comment">-- 修改项目</span></span><br><span class="line"><span class="keyword">select</span> *(其他查询条件) <span class="keyword">from</span> 表名; <span class="comment">-- 查询项目</span></span><br></pre></td></tr></tbody></table></figure>

<hr>
<h2 id="Data-Define-Language"><a href="#Data-Define-Language" class="headerlink" title="Data Define Language"></a>Data Define Language</h2><h2 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h2><hr>
<p>###　基础查询</p>
<p>如果没有明确排序查询结果，则结果是无序的。</p>
<p>空格是无意义的。</p>
<figure class="highlight sql"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> 字段<span class="number">1</span>, 字段<span class="number">2</span>··· <span class="keyword">FROM</span> 表名;  <span class="comment">-- 检索指定列</span></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> 表名; <span class="comment">--检索表中全部列</span></span><br></pre></td></tr></tbody></table></figure>

<p><strong>DISTINCT关键字</strong></p>
<p>在查询时，如果只想得到某个字段不同的取值，那么可以加上该关键字。</p>
<p>如下所示得到的查询结果就都是<strong>不重复</strong>的。</p>
<figure class="highlight sql"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> 字段<span class="number">1</span>，字段<span class="number">2</span> <span class="keyword">FROM</span> 表名;</span><br></pre></td></tr></tbody></table></figure>

<p><strong>LIMIT关键字</strong></p>
<p>用于限制查询结果得到的行数</p>
<figure class="highlight sql"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> 表名 <span class="keyword">LIMIT</span> m,n; <span class="comment">--从第m个数据开始显示,显示n条,m,n&gt;=0,整</span></span><br></pre></td></tr></tbody></table></figure>

<hr>
<h3 id="排序查询"><a href="#排序查询" class="headerlink" title="排序查询"></a>排序查询</h3><p><strong>ORDER BY以及DESC</strong></p>
<figure class="highlight sql"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> 字段<span class="number">1</span>, 字段<span class="number">2</span>··· <span class="keyword">FROM</span> 表名 <span class="keyword">ORDER</span> <span class="keyword">BY</span> 字段<span class="number">1</span>,字段<span class="number">2</span> <span class="keyword">DESC</span>; </span><br><span class="line"><span class="comment">-- ORDER BY表名按说明顺序进行排列;</span></span><br><span class="line"><span class="comment">-- DESC表明按照字段2降序, 默认升序, DESC只作用于前一个字段;</span></span><br><span class="line"><span class="comment">-- 如果想在多个列上进行降序排序，必须对每个列指定DESC关键字。</span></span><br></pre></td></tr></tbody></table></figure>

<p><strong>ORDER BY必须在FROM后, 使用LINIT也必须在ORDER BY之后.</strong></p>
<hr>
<h3 id="过滤数据"><a href="#过滤数据" class="headerlink" title="过滤数据"></a>过滤数据</h3><h4 id="WHERE"><a href="#WHERE" class="headerlink" title="WHERE"></a>WHERE</h4><figure class="highlight sql"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> 表名 <span class="keyword">WHERE</span> 过滤条件; <span class="comment">-- 若使用ORDER BY, 应处在WHERE的后面</span></span><br></pre></td></tr></tbody></table></figure>

<p><strong>WHERE</strong>后面衔接的过滤条件子句可以是：</p>
<ul>
<li>字段 = （&gt; , &lt; , !=, &gt;=, &lt;=）value</li>
<li>字段 BETWEEN m AND n</li>
<li>字段 IS NULL</li>
</ul>
<p><strong>组合WHERE</strong></p>
<p><strong>AND和OR 连接WHERE后得到多个条件</strong>，需注意优先级，AND高于OR。</p>
<p><strong>IN</strong>，用于控制WHERE后面字段选取范围。</p>
<figure class="highlight sql"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> 表名 <span class="keyword">WHERE</span> 属性 [<span class="keyword">NOT</span>] <span class="keyword">IN</span> 条件; <span class="comment">-- 这里的条件可以是一个范围，不过更常是另一个SELECT clause</span></span><br></pre></td></tr></tbody></table></figure>

<p>MySQL支持使用<strong>NOT</strong>对<strong>IN、BETWEEN和EXISTS</strong>子句<strong>取反</strong>，这与多数其他DBMS允许使用NOT对各种条件取反有很大的差别。</p>
<h4 id="通配符"><a href="#通配符" class="headerlink" title="通配符"></a>通配符</h4><p>搭配<strong>LIKE</strong>使用</p>
<ol>
<li><p>%通配符</p>
<figure class="highlight sql"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> 表名 <span class="keyword">WHERE</span> 属性 <span class="keyword">LIKE</span> S%; </span><br><span class="line"><span class="comment">-- 模糊查找，对应属性以S开头的所有行 </span></span><br><span class="line"><span class="comment">-- %代表任意字符（串）</span></span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p>_下划线通配符</p>
<figure class="highlight sql"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> 表名 <span class="keyword">WHERE</span> 属性 <span class="keyword">LIKE</span> S_B; </span><br><span class="line"><span class="comment">-- 模糊查找，对应属性以S开头B结尾中间只有一个字符的所有行 </span></span><br><span class="line"><span class="comment">-- _只代表单个任意字符</span></span><br></pre></td></tr></tbody></table></figure>

</li>
</ol>
<h4 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h4><p>使用 <strong>REGEXP</strong>说明自己要使用正则表达式。</p>
<figure class="highlight sql"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> 表名 <span class="keyword">WHERE</span> 属性 REGEXP <span class="string">'regular expression'</span>;</span><br><span class="line"><span class="comment">-- 表示OR ”|“</span></span><br></pre></td></tr></tbody></table></figure>

<p>[abc]edg，表示匹配abc中的某一个字符+edg</p>
<p><strong>[^abc]用于排除abc，匹配他们以外的东西。</strong></p>
<p><strong>^[abc]</strong>，匹配到的都以a或b或c开头。</p>
<p>[0-9a-z]也是可接受表达式。</p>
<p>匹配特殊字符时，使用 <strong>\\</strong>进行转义。</p>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>mySQL（六）</title>
    <url>/post/80a58d0e.html</url>
    <content><![CDATA[<h1 id="管理事务处理"><a href="#管理事务处理" class="headerlink" title="管理事务处理"></a>管理事务处理</h1><p>事物的四个特性：</p>
<p><strong>Atomic:</strong> 一个事务要么全部提交成功，要么全部失败回滚，不能只执行其中的一部分操作。</p>
<p>*<em>Consistency: *</em>一个事务在执行之前和执行之后，数据库都必须处于一致性状态。 </p>
<p>*<em>Isolation: *</em> 在并发环境中，并发的事务时相互隔离的，一个事务的执行不能不被其他事务干扰。</p>
<p>*<em>During: *</em>一旦事务提交，那么它对数据库中的对应数据的状态的变更就会永久保存到数据库中。</p>
<a id="more"></a>

<p>并非所有引擎都支持事务处理：MyISAM和InnoDB是两种最常用的引擎，而前者不支持明确的事务处理管理，后者支持。</p>
<p><strong>事务（transaction）</strong>指一组SQL语句；</p>
<p><strong>回退（rollback）</strong>指撤销指定SQL语句的过程；</p>
<p><strong>提交（commit）</strong>指将未存储的SQL语句结果写入数据库表；</p>
<p><strong>保留点（savepoint）</strong>指事务处理中设置的临时占位符（placeholder），你可以对它发布回退（与回退整个事务处理不同）。</p>
<h2 id="事务开始"><a href="#事务开始" class="headerlink" title="事务开始"></a>事务开始</h2><figure class="highlight sql"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">START</span> <span class="keyword">TRANSACTION</span></span><br></pre></td></tr></tbody></table></figure>



<h2 id="使用ROLLBACK"><a href="#使用ROLLBACK" class="headerlink" title="使用ROLLBACK"></a>使用ROLLBACK</h2><figure class="highlight sql"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> orderitems; <span class="comment">--先查询数据，都在</span></span><br><span class="line"><span class="keyword">START</span> <span class="keyword">TRANSACTION</span>;<span class="comment">-- 开始事务</span></span><br><span class="line"><span class="keyword">DELETE</span>  <span class="keyword">FROM</span> orderitems;<span class="comment">--删除表中数据</span></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> orderitems;<span class="comment">--查询是否删除</span></span><br><span class="line"><span class="keyword">ROLLBACK</span>;<span class="comment">--回滚</span></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> orderitems;<span class="comment">--删除的数据又重新出现</span></span><br></pre></td></tr></tbody></table></figure>



<h2 id="使用COMMIT"><a href="#使用COMMIT" class="headerlink" title="使用COMMIT"></a>使用COMMIT</h2><p>一般的MySQL语句都是直接针对数据库表执行和编写的，会自动提交，也叫做隐含提交。</p>
<figure class="highlight sql"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">SET</span> AUTOCOMMIT = <span class="number">0</span>; <span class="comment">-- 禁止自动提交</span></span><br></pre></td></tr></tbody></table></figure>



<p>但是在事务处理中，提交不会隐含地进行，必须使用<strong>COMMIT</strong>语句进行明确的提交。</p>
<p>COMMIT可以保证：在SQL语句不出错时才真正执行操作，否则错误语句会被自动撤销。</p>
<p>当COMMIT或ROLLBACK执行后，事务会自动关闭。</p>
<h2 id="使用保存点"><a href="#使用保存点" class="headerlink" title="使用保存点"></a>使用保存点</h2><p>只使用ROLLBACK和COMMIT的话明显不够人性化，一旦出错就会回滚到最开始的状态。</p>
<p>为了支持回退部分事务处理，必须能在事务处理块中合适的位置放置占位符，这些占位符被叫做保存点。</p>
<h3 id="创建保存点"><a href="#创建保存点" class="headerlink" title="创建保存点"></a>创建保存点</h3><figure class="highlight sql"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">SAVEPOINT</span> 保存点名;</span><br></pre></td></tr></tbody></table></figure>

<p>shi’y使用保存点</p>
<figure class="highlight sql"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">ROLLBACK</span> <span class="keyword">TO</span> 保存点名;</span><br></pre></td></tr></tbody></table></figure>



<h1 id="字符集"><a href="#字符集" class="headerlink" title="字符集"></a>字符集</h1><p><strong>字符集</strong>是字母和符号的集合；</p>
<p><strong>编码</strong>是某个字符集成员的内部表示；</p>
<p><strong>校对</strong>规定字符如何比较的指令。</p>
<p>通过<code>SHOW CHARACTER SET;</code>查看数据库可用的数据集。</p>
<h1 id="安全管理"><a href="#安全管理" class="headerlink" title="安全管理"></a>安全管理</h1><p>MySQL中用户信息都存储在mysql数据库中的user表中。可使用以下指令查看：</p>
<figure class="highlight sql"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">USE</span> mysql;</span><br><span class="line">CELECCT USER FROM USER;</span><br></pre></td></tr></tbody></table></figure>

<h2 id="创建用户"><a href="#创建用户" class="headerlink" title="创建用户"></a>创建用户</h2><figure class="highlight sql"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">USER</span> 用户名</span><br><span class="line"><span class="keyword">IDENTIFIED</span> <span class="keyword">BY</span> <span class="string">'口令'</span></span><br></pre></td></tr></tbody></table></figure>

<h2 id="用户重命名"><a href="#用户重命名" class="headerlink" title="用户重命名"></a>用户重命名</h2><figure class="highlight sql"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">RENAME</span> <span class="keyword">USER</span> 原名 <span class="keyword">TO</span> 新名</span><br></pre></td></tr></tbody></table></figure>

<h2 id="删除用户"><a href="#删除用户" class="headerlink" title="删除用户"></a>删除用户</h2><figure class="highlight sql"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">DROP</span> UESR 用户名;</span><br></pre></td></tr></tbody></table></figure>

<h2 id="设置权限"><a href="#设置权限" class="headerlink" title="设置权限"></a>设置权限</h2><p>在设置权限时，要求账号用户必须存在，但涉及的对象却没有这个要求。</p>
<p>这样可以：给未来的表设置权限、某表被删除后再出现时对它的权限依然存在。</p>
<figure class="highlight sql"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">-- 授予权限</span></span><br><span class="line"><span class="keyword">GRANT</span> <span class="keyword">INSERT</span> / <span class="keyword">DELETE</span> / <span class="keyword">UPDATE</span> / <span class="keyword">SELECT</span> <span class="keyword">ON</span> 数据库.表名 <span class="keyword">TO</span> 用户名;</span><br><span class="line"><span class="comment">-- 授予多个权限可以简化</span></span><br><span class="line"><span class="keyword">GRANT</span> <span class="keyword">INSERT</span>, <span class="keyword">ALTER</span>,<span class="keyword">UPDATE</span> <span class="keyword">ON</span> 数据库名.表名 <span class="keyword">TO</span>  用户名;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 取消权限</span></span><br><span class="line"><span class="comment">-- 被废除的权限必须存在</span></span><br><span class="line"><span class="keyword">REVOKE</span> <span class="keyword">INSERT</span> / <span class="keyword">DELETE</span> / <span class="keyword">UPDATE</span> / <span class="keyword">SELECT</span> <span class="keyword">ON</span> 数据库.表名 <span class="keyword">FROM</span> 用户名;</span><br></pre></td></tr></tbody></table></figure>

<p>可授予、废除的权限如下：</p>
<p><img src="https://gitee.com/man-ljw/PicBed/raw/master/QQ%E6%88%AA%E5%9B%BE20210708094316.jpg" alt=""></p>
<p><img src="https://gitee.com/man-ljw/PicBed/raw/master/QQ%E6%88%AA%E5%9B%BE20210708094437.jpg" alt=""></p>
<h2 id="更改密码"><a href="#更改密码" class="headerlink" title="更改密码"></a>更改密码</h2><figure class="highlight sql"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">SET</span> <span class="keyword">PASSWORD</span> FRO 用户名 = <span class="keyword">PASSWORD</span>(<span class="string">'新密码'</span>);</span><br></pre></td></tr></tbody></table></figure>



<h1 id="数据库备份"><a href="#数据库备份" class="headerlink" title="数据库备份"></a>数据库备份</h1><p>由于数据库数据经常是打开的，所以不能使用一般的文件转存方法，不过有以下几种解决方法：</p>
<ol>
<li>使用命令行实用程序mysqldump转储数据库所有内容。</li>
<li>可用命令行实用程序mysqlhotcopy从一个数据库复制所有数据（MyISAM，Innodb支持）。</li>
<li>使用MySQL的BACKUP TABLE或SELECT INTO OUTFILE转储所有数据到某个外部文件。</li>
</ol>
<p><strong>注：</strong>为了保证所有数据被写到磁盘（包括索引数据），可能需要在进行备份前使用<strong>FLUSH TABLES</strong>语句。</p>
<h1 id="MySQL日志"><a href="#MySQL日志" class="headerlink" title="MySQL日志"></a>MySQL日志</h1><ul>
<li>错误日志，位于Data目录下，通常命名时[主机名].err。</li>
<li>查询日志，位于Data目录下，通常命名时[主机名].log。</li>
<li>二进制日志。位于data目录下，通常命名为hostname-bin，它记录更新过数据（或者可能更新过数据）的所有语句。</li>
</ul>
<h1 id="性能"><a href="#性能" class="headerlink" title="性能"></a>性能</h1><p>使用<code>用SHOW PROCESSLIST</code>查看活动进程，并可以使用KILL+PID杀死进程（需要root）。</p>
<ul>
<li>一般来说，存储过程执行得比一条一条地执行其中的各条MySQL语句快。</li>
</ul>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>JZ50 数组中重复的数字</title>
    <url>/post/39ccbee0.html</url>
    <content><![CDATA[<p><a href="https://www.nowcoder.com/practice/6fe361ede7e54db1b84adc81d09d8524?tpId=13&amp;&amp;tqId=11203&amp;rp=1&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking" target="_blank" rel="noopener">数组中重复的数字  -  牛客网</a></p>
<h2 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h2><p>在一个长度为n的数组里的所有数字都在0到n-1的范围内。 数组中某些数字是重复的，但不知道有几个数字是重复的。也不知道每个数字重复几次。请找出数组中任一一个重复的数字。 例如，如果输入长度为7的数组[2,3,1,0,2,5,3]，那么对应的输出是2或者3。存在不合法的输入的话输出-1.</p>
<a id="more"></a>

<h2 id="示例1"><a href="#示例1" class="headerlink" title="示例1"></a>示例1</h2><figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">输入：[2,3,1,0,2,5,3]</span><br><span class="line">返回值：2</span><br><span class="line">说明：2或3都是对的</span><br></pre></td></tr></tbody></table></figure>



<h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>题的特殊点：<strong>长度为n的数组里的所有数字都在0到n-1的范围内</strong></p>
<p><strong>把元素 i 放在arr【i】上，若对应位置已有该元素，则重复复。</strong></p>
<p><strong>刚开始想法是以下标为主，找到对应的元素交换，但是这样时间还是O(n^2)。所以 是以数组元素为主，把元素放到对应的下标的数组中，这样就不用找元素了，并且每次都能把一个元素放到对应位置，直到发现重复</strong>。</p>
<h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.klaus.prob1;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] numbers)</span></span>{</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt; numbers.length;i++){</span><br><span class="line">            <span class="keyword">while</span>(numbers[i] != i){ <span class="comment">//while的原因是可能交换一次后，numbers[i] 依然不等于 i</span></span><br><span class="line">                <span class="keyword">if</span>(numbers[i] == numbers[numbers[i]])   <span class="comment">//把数组元素和元素作为下标对应的元素进行比较</span></span><br><span class="line">                    <span class="keyword">return</span> numbers[i];</span><br><span class="line">                <span class="keyword">int</span> tmp = numbers[numbers[i]];</span><br><span class="line">                numbers[numbers[i]] = numbers[i];</span><br><span class="line">                numbers[i] = tmp;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>剑指OFFER</tag>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title>JZ1 二维数组中的查找</title>
    <url>/post/d35944e1.html</url>
    <content><![CDATA[<h1 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h1><p>在一个二维数组中（每个一维数组的长度相同），每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。</p>
<a id="more"></a>
<h1 id="示例1"><a href="#示例1" class="headerlink" title="示例1"></a>示例1</h1><figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">输入： 7,[[1,2,8,9],[2,4,9,12],[4,7,10,13],[6,8,11,15]]</span><br><span class="line">返回值：true</span><br><span class="line">说明： 存在7，返回true</span><br></pre></td></tr></tbody></table></figure>

<h1 id="示例2"><a href="#示例2" class="headerlink" title="示例2"></a>示例2</h1><figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">输入：3,[[1,2,8,9],[2,4,9,12],[4,7,10,13],[6,8,11,15]]</span><br><span class="line">返回值：false</span><br><span class="line">说明：不存在3，返回false</span><br></pre></td></tr></tbody></table></figure>

<h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>如下图所示，这个数组元素规律性很强。左边的数小于右边的，下边的数小于上边的。</p>
<p>所以从右上角的数S开始比对检测，若target小于S，那么左移；若target大于S，下移一行。</p>
<p>这里的行、列变换还可以用二分查找的思想。。想起来的话再写吧。</p>
<p><img src="https://gitee.com/man-ljw/PicBed/raw/master/QQ%E6%88%AA%E5%9B%BE20210708195425.jpg" alt=""></p>
<h1 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h1><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">Find</span><span class="params">(<span class="keyword">int</span> target, <span class="keyword">int</span> [][] array)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span>(array.length==<span class="number">0</span> || array[<span class="number">0</span>].length==<span class="number">0</span>){</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">int</span> a = array.length;</span><br><span class="line">        <span class="keyword">int</span> b = array[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>, j=b-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(target != array[i][j]){</span><br><span class="line">            <span class="keyword">if</span>(i&lt;=a-<span class="number">1</span> &amp;&amp; j&gt;=<span class="number">0</span>){</span><br><span class="line">                <span class="keyword">if</span>(target &gt; array[i][j])</span><br><span class="line">                    i++;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (target &lt; array[i][j])</span><br><span class="line">                    j--;</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">if</span>(i&gt;a-<span class="number">1</span> || j&lt;<span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>剑指OFFER</tag>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title>JZ2 替换空格</title>
    <url>/post/906568b5.html</url>
    <content><![CDATA[<h1 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h1><p>请实现一个函数，将一个字符串中的每个空格替换成“%20”。例如，当字符串为We Are Happy.则经过替换之后的字符串为We%20Are%20Happy。<a id="more"></a></p>
<h1 id="示例1"><a href="#示例1" class="headerlink" title="示例1"></a>示例1</h1><figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">输入："We Are Happy"</span><br><span class="line">返回值："We%20Are%20Happy"</span><br></pre></td></tr></tbody></table></figure>



<h1 id="解答及思路"><a href="#解答及思路" class="headerlink" title="解答及思路"></a>解答及思路</h1><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">//1.Java提供的replace</span></span><br><span class="line"><span class="comment">//  使用的是regex，但是为什么快。。。</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">replaceSpace</span> <span class="params">(String s)</span> </span>{</span><br><span class="line">        <span class="comment">// write code here</span></span><br><span class="line">        String res = s.replace(<span class="string">" "</span>, <span class="string">"%20"</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    }</span><br><span class="line">​</span><br></pre></td></tr></tbody></table></figure>


<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line"></span><br><span class="line">```java</span><br><span class="line">//2. 创建中间char数组变量，遍历数组，把空格替换，不是空格的不变。</span><br><span class="line">//   巨慢！！！</span><br><span class="line">    public static String replaceSpace(String s){</span><br><span class="line">        int len =s.length();</span><br><span class="line">        char[] tmp = new char[len *3];</span><br><span class="line">        int index=0;</span><br><span class="line"></span><br><span class="line">        for (int i= 0;i&lt;len;i++){</span><br><span class="line">            if (s.charAt(i) ==' '){</span><br><span class="line">                tmp[index++] = '%';</span><br><span class="line">                tmp[index++] = '2';</span><br><span class="line">                tmp[index++] = '0';</span><br><span class="line">            }</span><br><span class="line">            else {</span><br><span class="line">                tmp[index++] = s.charAt(i);</span><br><span class="line">             }</span><br><span class="line">        }</span><br><span class="line">        return new String(tmp, 0, index);</span><br><span class="line">    }</span><br></pre></td></tr></tbody></table></figure>

<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>剑指OFFER</tag>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title>Java集合（一）</title>
    <url>/post/7bd591b8.html</url>
    <content><![CDATA[<p>Collecction系：</p>
<p><img src="https://gitee.com/man-ljw/PicBed/raw/master/Collection-Map.png" alt=""></p>
<a id="more"></a>

<h1 id="1-Collection接口"><a href="#1-Collection接口" class="headerlink" title="1.Collection接口"></a>1.Collection接口</h1><p>数组元素既可以是基本类型的值也可以是对象（对象的引用变量）；而集合里只能保存对象（对象的引用变量）。</p>
<h2 id="Collection方法"><a href="#Collection方法" class="headerlink" title="Collection方法"></a>Collection方法</h2><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span></span>;</span><br><span class="line"><span class="comment">//添加元素</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(E e)</span></span>;</span><br><span class="line"><span class="comment">//移除元素</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">cleat</span><span class="params">(E e)</span></span>;</span><br><span class="line"><span class="comment">//清空集合中元素</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(Object o)</span></span>;</span><br><span class="line"><span class="comment">//判断集合中是否包含指定元素</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">containsAll</span><span class="params">(Collection c)</span></span>;</span><br><span class="line"><span class="comment">//判断集合中是否包含集合c中的全部元素</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">//判断集合是否为空</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">size</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">//集合中元素的个数</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">retainALL</span><span class="params">(Collection c)</span></span>;</span><br><span class="line"><span class="comment">//只保留和集合c中有的元素</span></span><br></pre></td></tr></tbody></table></figure>



<h2 id="1-1Iterator"><a href="#1-1Iterator" class="headerlink" title="1.1Iterator"></a>1.1Iterator</h2><p>Iterator接口方法，可以通过Collection.iterator()方法得到实现类。</p>
<p>在遍历的过程中如果删除元素，会出现错误。原因是Iterator采用“快速失败机制”，一旦在迭代过程中检测到集合已经被修改，立即引发<strong>ConcurrentModificationException异常</strong>。</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">//如果还有元素没有被遍历，返回true</span></span><br><span class="line"><span class="function">Object <span class="title">next</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">//返回下一个元素，如果有的话</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">//删除上一次next()返回的元素</span></span><br></pre></td></tr></tbody></table></figure>

<h3 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h3><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.klaus.collection;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Collection;</span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Collect_1</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">        Collection &lt;String&gt; c = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        c.add(<span class="string">"Hello"</span>);</span><br><span class="line">        c.add(<span class="string">"World"</span>);</span><br><span class="line">        c.add(<span class="string">"!"</span>);</span><br><span class="line"></span><br><span class="line">        Iterator&lt;String&gt; i = c.iterator();</span><br><span class="line">        <span class="keyword">while</span> (i.hasNext()){</span><br><span class="line">            System.out.print(i.next()+<span class="string">" "</span>);</span><br><span class="line">        }</span><br><span class="line">        System.out.println(<span class="string">""</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"c.contains(\"Hello\"): "</span>+c.contains(<span class="string">"Hello"</span>));</span><br><span class="line">        System.out.println(<span class="string">"c.contains(\"Hell\"): "</span>+c.contains(<span class="string">"Hell"</span>));</span><br><span class="line">        c.remove(<span class="string">"Hello"</span>);</span><br><span class="line">        System.out.println(<span class="string">"c.contains(\"Hello\"): "</span>+c.contains(<span class="string">"Hello"</span>));       </span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>运行结果如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">Hello World ! </span><br><span class="line">c.contains("Hello"): true</span><br><span class="line">c.contains("Hell"): false</span><br><span class="line">c.contains("Hello"): false</span><br></pre></td></tr></tbody></table></figure>



<p><strong>foreach</strong>访问更简洁</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (String s:c){</span><br><span class="line">     System.out.print(s+<span class="string">" "</span>);</span><br><span class="line"> }</span><br><span class="line"> System.out.println(<span class="string">""</span>);</span><br></pre></td></tr></tbody></table></figure>



<h2 id="1-2-Set集合"><a href="#1-2-Set集合" class="headerlink" title="1.2 Set集合"></a>1.2 Set集合</h2><p><strong>无序、不重复。</strong></p>
<p>Set和Collection相比没有提供任何额外的方法。使用也类似。</p>
<h3 id="1-2-1-HashSet类"><a href="#1-2-1-HashSet类" class="headerlink" title="1.2.1 HashSet类"></a>1.2.1 HashSet类</h3><ul>
<li><p>HashSet使用Hash算法来存储集合中的元素。</p>
</li>
<li><p>HashSet中元素顺序与添加顺序可能不一样。</p>
</li>
<li><p>hashCode()返回值是在HashSet中的索引。</p>
</li>
</ul>
<p>添加元素时，HashSet会调用<strong>待添加对象</strong>的<code>hashCode()</code>方法得到对应的哈希值，然后由<strong>哈希值</strong>决定该对象在HashSet中的存储位置。</p>
<p><font style="color:red" size="5">A.equals(B)返回true，则A.hashCode() == B.hashCode()。<br></font></p>
<p>特殊情况：</p>
<ol>
<li><p>equals()比较返回true，但hashCode()不一样。</p>
<p>此时HashSet会把两个对象根据不同的哈希值存储到对应位置，但与Set<strong>不重复</strong>的原则矛盾。</p>
</li>
<li><p>hashCode()相同，但equals()比较返回false。</p>
<p>在同样的位置（由哈希值决定）通过链式结构把两个对象存储，但这样会导致性能下降。</p>
</li>
</ol>
<h3 id="1-2-2LinkedHasgSet类"><a href="#1-2-2LinkedHasgSet类" class="headerlink" title="1.2.2LinkedHasgSet类"></a>1.2.2LinkedHasgSet类</h3><p>元素的位置依然由hashCode值决定。与HashSet不同的是，LinkedHashSet使用<strong>链表</strong>维护元素的次序，这样就可以使元素遍历时看起来是以插入的顺序保存的。</p>
<p>因此性能略低于HashSet，<strong>但在迭代全部元素时由很好的性能</strong>。</p>
<h3 id="1-2-3TreeSet"><a href="#1-2-3TreeSet" class="headerlink" title="1.2.3TreeSet"></a>1.2.3TreeSet</h3><p>TreeSet是SortedSet接口的实现类，保证集合元素处于排序状态。</p>
<p>重要方法：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function">SortedSet <span class="title">subSet</span><span class="params">(fromElement, toElement)</span></span>;</span><br><span class="line"><span class="comment">//返回此Set的子集，范围是[fromElement, toElement)</span></span><br></pre></td></tr></tbody></table></figure>



<p>排序方法由自然排序、定制排序两种。</p>
<p><strong>自然排序</strong>就是调用集合元素的<font style="color: red">compareTO(Object o)</font>方法比较元素，然后按照<strong>升序</strong>排列。</p>
<p>在把对象作为元素加入HashSet中时，对象的类必须实现Comparable接口；加入一个对象后，以后只能加入该类型的对象，否则会有<code>ClassCastException</code>。</p>
<p>在添加新元素时，<strong>唯一的判别标准是compareTo()是否返回零</strong>。</p>
<p>对象被添加后，改变对象内用于比较的属性的值的话，它在TreeSet中的位置不会改变。</p>
<table>
<thead>
<tr>
<th align="center">类型</th>
<th align="center">比较方法</th>
</tr>
</thead>
<tbody><tr>
<td align="center">Character</td>
<td align="center">UNICODE</td>
</tr>
<tr>
<td align="center">数值类型（Integer，BigInteger等）</td>
<td align="center">按数值大小</td>
</tr>
<tr>
<td align="center">Boolean</td>
<td align="center">true&gt;false</td>
</tr>
<tr>
<td align="center">String</td>
<td align="center">串中字符的UNICODE</td>
</tr>
<tr>
<td align="center">Date、Time</td>
<td align="center">后面的日期&gt;前面的日期</td>
</tr>
</tbody></table>
<p><strong>定制排序</strong>需要通过Comparator接口的帮助，定义其<code>compare(Object o1, Object o2)</code>函数，根据返回结果排序。</p>
<p>在添加新元素时，<strong>唯一的判别标准是compare(Object o1, Object o2)是否返回零</strong>；返回0则不会把第二个元素添加。</p>
<h3 id="1-2-4EnumSet类"><a href="#1-2-4EnumSet类" class="headerlink" title="1.2.4EnumSet类"></a>1.2.4EnumSet类</h3><p>专门为枚举元素设计的类。</p>
<p>EnumSet集合元素也是<strong>有序</strong>的。</p>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>JZ19 顺时针打印矩阵</title>
    <url>/post/2c0ee3a9.html</url>
    <content><![CDATA[<h1 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h1><p>输入一个矩阵，按照从外向里以顺时针的顺序依次打印出每一个数字，例如，如果输入如下4 X 4矩阵：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">[[1,2,3,4],</span><br><span class="line">[5,6,7,8],</span><br><span class="line">[9,10,11,12],</span><br><span class="line">[13,14,15,16]]</span><br></pre></td></tr></tbody></table></figure>

<p>则依次打印出数字</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">[1,2,3,4,8,12,16,15,14,13,9,5,6,7,11,10]</span><br></pre></td></tr></tbody></table></figure>

<a id="more"></a>

<h1 id="示例1"><a href="#示例1" class="headerlink" title="示例1"></a>示例1</h1><figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">输入：[[1,2],[3,4]]</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">返回值：[1,2,4,3]</span><br></pre></td></tr></tbody></table></figure>

<h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>如下图，要这样循环打印数组元素，可以看成 打印不同外圈的元素。因为横竖左右都有限定并且循环方向也一直在变，所以需要四个变量r1, rows, c1, cols界定循环边缘。</p>
<p>每一个外圈打印规则是：先➡打印上面那一行，⬇ 打印右边一列，⬅打印下面一行，⬆ 打印左边一列。每次打印完一行或者一列后，其界定变量要跟着变化（+1或者-1，为了不重复打印拐角元素）。对于下面一行和左边一列，要判断行列的界定元素不相等，否则就会重复。</p>
<img src="https://gitee.com/man-ljw/PicBed/raw/master/QQ截图20210710084453.jpg" align="left">

<h1 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h1><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ArrayList&lt;Integer&gt; <span class="title">printMatrix</span><span class="params">(<span class="keyword">int</span> [][] matrix)</span> </span>{</span><br><span class="line">        <span class="keyword">int</span> rows = matrix.length;</span><br><span class="line">        <span class="keyword">int</span> cols = matrix[<span class="number">0</span>].length;</span><br><span class="line">        ArrayList&lt;Integer&gt; arr = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> r1 = <span class="number">0</span>,c1 =<span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> (r1&lt;=rows-<span class="number">1</span> &amp;&amp; c1 &lt;= cols-<span class="number">1</span>){</span><br><span class="line">            <span class="comment">// ➡打印上面一行</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j=c1;j&lt;cols;j++){</span><br><span class="line">                arr.add(matrix[r1][j]);</span><br><span class="line">            }</span><br><span class="line">            r1++;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// ⬇ 打印右边一列</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = r1;i&lt;rows;i++){</span><br><span class="line">                arr.add(matrix[i][cols-<span class="number">1</span>]);</span><br><span class="line">            }</span><br><span class="line">            rows--;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//⬅打印下面一行</span></span><br><span class="line">            <span class="keyword">if</span>(r1!=rows+<span class="number">1</span>) {</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = cols - <span class="number">2</span>; j &gt;= c1; j--) {</span><br><span class="line">                    arr.add(matrix[rows][j]);</span><br><span class="line">                }</span><br><span class="line">                cols--;</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">            <span class="comment">//⬆ 打印左边一列</span></span><br><span class="line">            <span class="keyword">if</span>(c1!=cols) {</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = rows - <span class="number">1</span>; i &gt;= r1; i--) {</span><br><span class="line">                    arr.add(matrix[i][c1]);</span><br><span class="line">                }</span><br><span class="line">                c1++;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> arr;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>剑指OFFER</tag>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title>Java集合（二）</title>
    <url>/post/4bc37d60.html</url>
    <content><![CDATA[<h1 id="List集合"><a href="#List集合" class="headerlink" title="List集合"></a>List集合</h1><p>List集合是一个<strong>有序、可重复</strong>的集合。每个元素按添加顺序设置索引，第一个添加的索引为0，依次递增。List通过顺序索引来访问元素。</p>
<p>List作为Collection的子接口，除了可以使用Collection的所有方法还多了根据索引操作元素的方法：<a id="more"></a></p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> index, Object element)</span></span>;</span><br><span class="line"><span class="comment">//添加元素到指定下标处</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">addAll</span><span class="params">(<span class="keyword">int</span> index, Collection c)</span></span>;</span><br><span class="line"><span class="comment">//把集合c中的全部元素以index为起始索引添加进List</span></span><br><span class="line"><span class="function">Object <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span></span>;</span><br><span class="line"><span class="comment">//获得index处的元素</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">indexOf</span><span class="params">(Object o)</span></span>;</span><br><span class="line"><span class="comment">//获得o在List中第一出现的索引，不存在的话返回-1</span></span><br><span class="line"><span class="function">Object <span class="title">remove</span><span class="params">(<span class="keyword">int</span> index)</span></span>;</span><br><span class="line"><span class="comment">//删除并返回index位置的元素</span></span><br><span class="line"><span class="function">Object <span class="title">set</span><span class="params">(<span class="keyword">int</span> index, Object o)</span></span>;</span><br><span class="line"><span class="comment">//将index位置的元素替换成o，并返回o</span></span><br><span class="line"><span class="function">List <span class="title">subList</span><span class="params">(<span class="keyword">int</span> fromList, <span class="keyword">int</span> toList)</span></span>;</span><br><span class="line"><span class="comment">//返回下标在[fromList, toList)的元素组成的子List集合</span></span><br></pre></td></tr></tbody></table></figure>

<p>List判断相等的标准是：<strong>equals()返回true</strong>。</p>
<h2 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h2><p>List除了iterator()（获得的迭代器只能向后迭代）外，还提供了listIterator()方法，返回一个ListIterator对象，ListIterator接口继承了Iterator接口，并增加了以下方法：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">hasPrevious</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">//是否还有上一个元素</span></span><br><span class="line"><span class="function">Object <span class="title">Previous</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">//返回上一个元素</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">//插入一个元素</span></span><br></pre></td></tr></tbody></table></figure>

<p>下面是ListIterator的示例。</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.klaus.collection;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.ListIterator;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ListTest</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line"></span><br><span class="line">        List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        list.add(<span class="string">"Hello"</span>);</span><br><span class="line">        list.add(<span class="string">"owo"</span>);</span><br><span class="line">        list.add(<span class="number">1</span>,<span class="string">"world"</span>);</span><br><span class="line"></span><br><span class="line">        ListIterator&lt;String&gt; listIterator = list.listIterator();</span><br><span class="line">        <span class="keyword">while</span> (listIterator.hasNext()){</span><br><span class="line">            System.out.println(listIterator.next());</span><br><span class="line">            listIterator.add(<span class="string">"---"</span>);</span><br><span class="line">        }</span><br><span class="line">        System.out.println(<span class="string">"反向迭代"</span>);</span><br><span class="line">        <span class="keyword">while</span> (listIterator.hasPrevious()){</span><br><span class="line">            System.out.println(listIterator.previous());</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>输出如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">Hello</span><br><span class="line">world</span><br><span class="line">owo</span><br><span class="line">反向迭代</span><br><span class="line">---</span><br><span class="line">owo</span><br><span class="line">---</span><br><span class="line">world</span><br><span class="line">---</span><br><span class="line">Hello</span><br></pre></td></tr></tbody></table></figure>

<h2 id="ArrayList和Vector"><a href="#ArrayList和Vector" class="headerlink" title="ArrayList和Vector"></a>ArrayList和Vector</h2><hr>
<p>ArrayList和Vector作为List的实现类，完全支持List接口的所有方法。其内部封装了一个动态的、允许再分配的Object[]，ArrayList和Vector对象通过initialCapacity参数指定数组长度，当超过时会自动增加。</p>
<p>在创建时如果不指定他们的大小，那么默认为<strong>10</strong>。</p>
<p>此外，</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ensureCapacity</span><span class="params">(<span class="keyword">int</span> minCapacity)</span></span>; <span class="comment">//将ArrayList和Vector的长度增加minCapacity</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">trimToSize</span><span class="params">()</span></span>;<span class="comment">//调整大小，使长度刚好等于当前元素个数</span></span><br></pre></td></tr></tbody></table></figure>



<p><strong>注：</strong>ArrayList是<strong>线程不安全的</strong>，当有超过一个线程修改集合时，需要<strong>手动</strong>保证集合的同步性。</p>
<pre><code>Vector是**线程安全的**，所以性能比ArrayList低。</code></pre><h2 id="解决Vector线程不安全"><a href="#解决Vector线程不安全" class="headerlink" title="解决Vector线程不安全"></a>解决Vector线程不安全</h2><hr>
<h3 id="Collections-synchronizedList"><a href="#Collections-synchronizedList" class="headerlink" title="Collections.synchronizedList()"></a>Collections.synchronizedList()</h3><p>​        使用<code>Collections.synchronizedList();</code>可以得到一个线程安全的 ArrayList。</p>
<h3 id="CopyOnWriteArrayList"><a href="#CopyOnWriteArrayList" class="headerlink" title="CopyOnWriteArrayList"></a>CopyOnWriteArrayList</h3><p>使用concurrent包下的CopyOnWriteArrayList 类。</p>
<p><strong>原因：读写分离</strong></p>
<p>写操作在一个复制的数组上进行，读操作还是在原始数组中进行，读写分离，互不影响。</p>
<p>写操作需要加锁，防止并发写入时导致写入数据丢失。</p>
<p>写操作结束之后需要把原始数组指向新的复制数组。</p>
<p><strong>适用场景</strong></p>
<p>CopyOnWriteArrayList 在写操作的<strong>同时允许读操作</strong>，大大提高了读操作的性能，因此很适合<strong>读多写少</strong>的应用场景。</p>
<p>但是 CopyOnWriteArrayList 有其缺陷：</p>
<ul>
<li>内存占用：在写操作时需要复制一个新的数组，使得内存占用为原来的两倍左右；</li>
<li>数据不一致：读操作不能读取实时性的数据，因为部分写操作的数据还未同步到读数组中。</li>
</ul>
<p>所以 CopyOnWriteArrayList 不适合内存敏感以及对实时性要求很高的场景。</p>
<h2 id="Stack类"><a href="#Stack类" class="headerlink" title="Stack类"></a>Stack类</h2><hr>
<p>Vector还提供了Stack子类，模拟栈的特点FILO。因为Stack继承了Vector，所以也是<strong>线程安全的</strong>。</p>
<p>其进栈出栈的都是Object，所以取出后要进行类型转换。</p>
<p>主要方法有：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function">Object <span class="title">peek</span><span class="params">()</span></span>; <span class="comment">//返回栈顶元素但并不弹出</span></span><br><span class="line"><span class="function">Object <span class="title">pop</span><span class="params">()</span></span>;<span class="comment">//弹出栈顶元素</span></span><br><span class="line"><span class="function">Object <span class="title">push</span><span class="params">(Object o)</span></span>;<span class="comment">//将o入栈</span></span><br></pre></td></tr></tbody></table></figure>

<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>ArrayList补充</title>
    <url>/post/b4b62cca.html</url>
    <content><![CDATA[<h1 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h1><p>ArrayList共有三种构造方法：</p>
<h2 id="1-无参构造"><a href="#1-无参构造" class="headerlink" title="1. 无参构造"></a>1. 无参构造</h2><p>​        创建一个长度10的Object数组。</p>
<h2 id="2-参数是int型-0-2-31-1）"><a href="#2-参数是int型-0-2-31-1）" class="headerlink" title="2.参数是int型 [0~2^31-1）"></a>2.参数是int型 [0~2^31-1）</h2><p>​        若参数大于0，创建指定长度的Object[]；</p>
<p>​        若参数等于0，Object类型的<strong>空数组</strong>；</p>
<p>​        其他情况，抛出异常。</p>
<h2 id="3-参数是Collectinon"><a href="#3-参数是Collectinon" class="headerlink" title="3.参数是Collectinon"></a>3.参数是Collectinon</h2><p>​        创建一个包含集合c所有元素的List，元素集合和集合Iterator遍历得到的元素顺序一样。<a id="more"></a></p>
<h1 id="void-trimToSize"><a href="#void-trimToSize" class="headerlink" title="void trimToSize()"></a>void trimToSize()</h1><p>若List中元素个数小于List长度，进行判断：</p>
<p>元素个数为0，trim后返回空Object数组；</p>
<p>否则的话通过<code>Arrays.copyOf(Object [], int size)</code>进行trim。</p>
<h1 id="扩容函数"><a href="#扩容函数" class="headerlink" title="扩容函数"></a>扩容函数</h1><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">//以下是ArrayList的部分源码</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>{</span><br><span class="line">    ensureCapacityInternal(size + <span class="number">1</span>);  <span class="comment">// Increments modCount!!</span></span><br><span class="line">    elementData[size++] = e;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureCapacityInternal</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>{</span><br><span class="line">    ensureExplicitCapacity(calculateCapacity(elementData, minCapacity));</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">calculateCapacity</span><span class="params">(Object[] elementData, <span class="keyword">int</span> minCapacity)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) {</span><br><span class="line">       <span class="keyword">return</span> Math.max(DEFAULT_CAPACITY, minCapacity);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> minCapacity;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureExplicitCapacity</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>{</span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="comment">// overflow-conscious code</span></span><br><span class="line">    <span class="keyword">if</span> (minCapacity - elementData.length &gt; <span class="number">0</span>)</span><br><span class="line">        grow(minCapacity);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">grow</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>{</span><br><span class="line">    <span class="comment">// overflow-conscious code</span></span><br><span class="line">    <span class="keyword">int</span> oldCapacity = elementData.length;</span><br><span class="line">    <span class="keyword">int</span> newCapacity = oldCapacity + (oldCapacity &gt;&gt; <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (newCapacity - minCapacity &lt; <span class="number">0</span>)</span><br><span class="line">        newCapacity = minCapacity;</span><br><span class="line">    <span class="keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="number">0</span>)</span><br><span class="line">        newCapacity = hugeCapacity(minCapacity);</span><br><span class="line">    <span class="comment">// minCapacity is usually close to size, so this is a win:</span></span><br><span class="line">    elementData = Arrays.copyOf(elementData, newCapacity);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h2 id="void-grow-int-minCapacity"><a href="#void-grow-int-minCapacity" class="headerlink" title="void grow(int minCapacity)"></a>void grow(int minCapacity)</h2><p>ArrayList扩容的核心函数。每次扩容后至少是原容量的1.5倍，若1.5倍容量仍不够，那么newCapacity直接设为minCapacity。最后如果newCapacity &gt; MaxArrraySize 的话，使用hugeCapacity(int )比较minCapacity和MAX_ARRAY_SIZE的大小，如果前者大，那么新容量就是Integer.Max_Value，否则就是MAX_ARRAY_SIZE。</p>
<p>也就是说：ArrayList并非是无限大的，它最大可以扩容到2^31-1。</p>
<p><strong>注：</strong>MAX_ARRAY_SIZE = Integer.MAX_VALUE - 8，这里减8的原因是需要8bit存储元信息。</p>
<h2 id="boolean-add-E-e"><a href="#boolean-add-E-e" class="headerlink" title="boolean add(E e)"></a>boolean add(E e)</h2><p>添加时先调用<code>ensureCapacityInternal(int minCapacity)</code>方法把数组容量增加1；</p>
<p>然后将待添加的元素加入。</p>
<h2 id="ensureCapacityInternal-int-minCapacity"><a href="#ensureCapacityInternal-int-minCapacity" class="headerlink" title="ensureCapacityInternal(int minCapacity)"></a>ensureCapacityInternal(int minCapacity)</h2><p>该函数调用利用ensureExplicitCapacity()函数得到最小扩容量。</p>
<h2 id="calculateCapacity"><a href="#calculateCapacity" class="headerlink" title="calculateCapacity()"></a>calculateCapacity()</h2><figure class="highlight plain"><figcaption><span>elementData, int minCapacity)```计算最小空间：</span></figcaption><table><tbody><tr><td class="code"><pre><span class="line"></span><br><span class="line">若elementData为空，那么返回max(10, minCapacity)；否则返回minCapacity。</span><br><span class="line"></span><br><span class="line"># remove函数</span><br><span class="line"></span><br><span class="line">删除的**时间复杂度为 O(N)**。</span><br><span class="line"></span><br><span class="line">```JAVA</span><br><span class="line">public E remove(int index) {</span><br><span class="line">        rangeCheck(index);//检查index是否合法</span><br><span class="line"></span><br><span class="line">        modCount++;</span><br><span class="line">        E oldValue = elementData(index);//获取被删除的元素</span><br><span class="line"></span><br><span class="line">        int numMoved = size - index - 1;//删除一个元素后，后面要向前移动的元素的个数</span><br><span class="line">        if (numMoved &gt; 0)</span><br><span class="line">            System.arraycopy(elementData, index+1, elementData, index,</span><br><span class="line">                             numMoved);</span><br><span class="line">        elementData[--size] = null; // clear to let GC do its work</span><br><span class="line">	    //都向前移一位，所以最后以为置为null并将size-1</span><br><span class="line">        return oldValue;</span><br><span class="line">    }</span><br></pre></td></tr></tbody></table></figure>

<h2 id="fastRemove-int-index"><a href="#fastRemove-int-index" class="headerlink" title="fastRemove (int index)"></a>fastRemove (int index)</h2><p>用于remove(Obj o)，较于remove(int index)只少了对index合法性的检测，以及不返回被删除的元素。</p>
<h1 id="序列化"><a href="#序列化" class="headerlink" title="序列化"></a>序列化</h1><p>ArrayList 基于数组实现，并且具有动态扩容特性，因此保存元素的数组不一定都会被使用，那么就没必要全部进行序列化。</p>
<p>保存元素的数组 elementData 使用 transient 修饰，该关键字声明数组默认不会被序列化。</p>
<p>序列化时需要使用 ObjectOutputStream 的 writeObject() 将对象转换为字节流并输出。而 writeObject() 方法在传入的对象存在 writeObject() 的时候会去反射调用该对象的 writeObject() 来实现序列化。反序列化使用的是 ObjectInputStream 的 readObject() 方法，原理类似。</p>
<h1 id="Fail-Fast"><a href="#Fail-Fast" class="headerlink" title="Fail-Fast"></a>Fail-Fast</h1><p>modCount 用来记录 ArrayList 结构发生变化的次数。结构发生变化是指<strong>添加</strong>或者<strong>删除</strong>至少一个元素的所有操作，或者是<strong>调整</strong>内部数组的<strong>大小</strong>，仅仅只是设置元素的值不算结构发生变化。</p>
<p>在进行序列化或者迭代等操作时，需要比较操作前后 modCount 是否改变，如果改变了需要抛出 ConcurrentModificationException。</p>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>JZ20 包含min函数的栈</title>
    <url>/post/f743ffaa.html</url>
    <content><![CDATA[<p><a href="https://www.nowcoder.com/practice/4c776177d2c04c2494f2555c9fcc1e49?tpId=13&amp;&amp;tqId=11173&amp;rp=1&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking" target="_blank" rel="noopener">原题链接</a></p>
<h2 id="JZ20-包含min函数的栈"><a href="#JZ20-包含min函数的栈" class="headerlink" title="JZ20 包含min函数的栈"></a>JZ20 包含min函数的栈</h2><h2 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h2><p>定义栈的数据结构，请在该类型中实现一个能够得到栈中所含最小元素的min函数，并且调用 min函数、push函数 及 pop函数 的时间复杂度都是 O(1)。</p>
<p>push(value):将value压入栈中；</p>
<p>pop():弹出栈顶元素；</p>
<p>top():获取栈顶元素；</p>
<p>min():获取栈中最小元素。<a id="more"></a></p>
<h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">输入：["PSH-1","PSH2","MIN","TOP","POP","PSH1","TOP","MIN"]</span><br><span class="line">返回值：-1,2,1,-1</span><br></pre></td></tr></tbody></table></figure>

<h2 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h2><p>要求时间复杂度都是O（1），所以一定要保存最小值。</p>
<p>一开始的想法是用中间保存，每次push时更新，但忘了pop也会改变min的值，并且pop之后需要<strong>历史最小值</strong>。于是换了思路想用char[]保存最小值，但是发现当一个数同时在栈中出现9次以上（两位数）时，就没办法保存了。</p>
<p>最后看了题解有了如下两种解法：</p>
<h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><p>这种方法使用变量存储最小值，保证了每次<strong>在新的最小值之前啊，存储了上一次最小值</strong>。</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Stack;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>{</span><br><span class="line">    Stack&lt;Integer&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    <span class="keyword">int</span> tmp = <span class="number">0x7fffffff</span>;<span class="comment">//存储最小值</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> node)</span> </span>{</span><br><span class="line">        <span class="comment">//一开始栈中没有元素</span></span><br><span class="line">        <span class="keyword">if</span>(stack.empty()) {</span><br><span class="line">            stack.push(node);</span><br><span class="line">            tmp=node;</span><br><span class="line">        }<span class="keyword">else</span>{</span><br><span class="line">            <span class="comment">//待入栈元素比当前最小值还小/相等</span></span><br><span class="line">            <span class="keyword">if</span>(node&lt;=tmp){</span><br><span class="line">                stack.push(tmp);<span class="comment">//保存历史最小值</span></span><br><span class="line">                tmp = node;<span class="comment">//更新最小值</span></span><br><span class="line">            }</span><br><span class="line">            stack.push(node);<span class="comment">//新元素入栈</span></span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pop</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">if</span>(stack.empty()){}</span><br><span class="line">        <span class="comment">//2. 栈顶元素等于最小值</span></span><br><span class="line">        <span class="keyword">if</span>(tmp == stack.peek()){</span><br><span class="line">            <span class="keyword">if</span>(stack.size()&gt;<span class="number">1</span>){</span><br><span class="line">                stack.pop();</span><br><span class="line">                tmp = stack.peek();<span class="comment">//上一个最小值</span></span><br><span class="line">            }<span class="keyword">else</span>{</span><br><span class="line">                tmp =<span class="number">0x7fffffff</span>;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        stack.pop();</span><br><span class="line">        <span class="comment">//1. 栈顶元素不等于最小值</span></span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">top</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> stack.peek();</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">min</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> tmp;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>这个使用了两个栈。刚开始栈都空的时候，正常push第一个元素；</p>
<p>以后每次minStack值push自己栈顶元素与待入栈元素中<strong>最小</strong>的一个，依次来存储历史最小值。</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Stack;</span><br><span class="line"></span><br><span class="line"><span class="comment">//双栈，用另一个栈保存min</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>{</span><br><span class="line">    <span class="keyword">private</span> Stack&lt;Integer&gt; dataStack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> Stack&lt;Integer&gt; minStack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> node)</span> </span>{</span><br><span class="line">        dataStack.push(node);</span><br><span class="line">        minStack.push(minStack.isEmpty() ? node : Math.min(minStack.peek(), node));</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pop</span><span class="params">()</span> </span>{</span><br><span class="line">        dataStack.pop();</span><br><span class="line">        minStack.pop();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">top</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> dataStack.peek();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">min</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> minStack.peek();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>



<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>剑指OFFER</tag>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title>JZ34 第一个只出现一次的字符位置</title>
    <url>/post/5cb7c635.html</url>
    <content><![CDATA[<p><a href="https://www.nowcoder.com/practice/1c82e8cf713b4bbeb2a5b31cf5b0417c?tpId=13&amp;&amp;tqId=11187&amp;rp=1&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking" target="_blank" rel="noopener">原题链接</a></p>
<h1 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h1><p>在一个字符串(0&lt;=字符串长度&lt;=10000，全部由字母组成)中找到第一个只出现一次的字符,并返回它的位置, 如果没有则返回 -1（需要区分大小写）.（从0开始计数）<a id="more"></a></p>
<h1 id="示例1"><a href="#示例1" class="headerlink" title="示例1"></a>示例1</h1><figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">输入："google"</span><br><span class="line">返回值：4</span><br></pre></td></tr></tbody></table></figure>

<h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>还没有学到map，所以用数组模拟，str中的字符做key，数组中的值做value，一边遍历后统计字符，然后再根据str中字符的顺序依次遍历，value为1的就是要的结果。当时这里没想明白，总是想用数组下标进行遍历，但这样就没办法满足题设中<code>第一个</code>的要求，卡了很久。</p>
<h1 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h1><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">FirstNotRepeatingChar</span><span class="params">(String str)</span> </span>{</span><br><span class="line">    <span class="keyword">int</span>[] map = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">128</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;str.length();i++)</span><br><span class="line">        ++map[str.charAt(i)];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;str.length(); ++i) {<span class="comment">//这里是没想到的，直接用字符串进行遍历！！</span></span><br><span class="line">        <span class="keyword">if</span> (map[str.charAt(i)] == <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>剑指OFFER</tag>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title>JZ5 用两个栈实现队列</title>
    <url>/post/3e80c40.html</url>
    <content><![CDATA[<p><a href="https://www.nowcoder.com/practice/54275ddae22f475981afa2244dd448c6?tpId=13&amp;&amp;tqId=11158&amp;rp=1&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking" target="_blank" rel="noopener">原题链接</a></p>
<h2 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h2><p>用两个栈来实现一个队列，分别完成在队列尾部插入整数(push)和在队列头部删除整数(pop)的功能。 队列中的元素为int类型。保证操作合法，即保证pop操作时队列内已有元素。</p>
<a id="more"></a>

<h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">输入：["PSH1","PSH2","POP","POP"]</span><br><span class="line"></span><br><span class="line">返回值：1,2</span><br></pre></td></tr></tbody></table></figure>

<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>把stack1用于push，stack2用于pop达到队列FIFO的效果。没有限制两个栈的大小，所以第一次pop时直接把stack1的pop顺序push进stack2，然后stack2进行pop即可。</p>
<p>但是第二次pop时，就不能再像刚才那样了，因为stack2如果还有元素的话，说明这些元素都比stack1栈底的元素入站早。所以再有pop时要把stack2的元素顺序pop完，才能输出stack1的元素。</p>
<h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Stack;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>{</span><br><span class="line">    Stack&lt;Integer&gt; stack1 = <span class="keyword">new</span> Stack&lt;Integer&gt;();</span><br><span class="line">    Stack&lt;Integer&gt; stack2 = <span class="keyword">new</span> Stack&lt;Integer&gt;();</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> node)</span> </span>{</span><br><span class="line">        stack1.push(node);</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">pop</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">if</span>(stack2.empty()){</span><br><span class="line">            <span class="keyword">while</span>(!stack1.empty()){</span><br><span class="line">                stack2.push(stack1.pop());</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">return</span> stack2.pop();</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> stack2.pop();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>剑指OFFER</tag>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title>JZ21 栈的压入、弹出序列</title>
    <url>/post/8e4b09f7.html</url>
    <content><![CDATA[<p><a href="https://www.nowcoder.com/practice/d77d11405cc7470d82554cb392585106?tpId=13&amp;tqId=11174&amp;tPage=1&amp;rp=1&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking&amp;from=cyc_github" target="_blank" rel="noopener">原题链接</a></p>
<h2 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h2><hr>
<p>输入两个整数序列，第一个序列表示栈的压入顺序，请判断第二个序列是否可能为该栈的弹出顺序。假设压入栈的所有数字均不相等。例如序列1,2,3,4,5是某栈的压入顺序，序列4,5,3,2,1是该压栈序列对应的一个弹出序列，但4,3,5,1,2就不可能是该压栈序列的弹出序列。（注意：这两个序列的长度是相等的）<a id="more"></a></p>
<h2 id="示例1"><a href="#示例1" class="headerlink" title="示例1"></a>示例1</h2><hr>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">输入：[1,2,3,4,5],[4,3,5,1,2]</span><br><span class="line"></span><br><span class="line">返回值：false</span><br></pre></td></tr></tbody></table></figure>



<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><hr>
<p>用一个栈模拟这个过程。</p>
<p>① 将pushA的第一个未入栈的元素入栈，然后判断栈顶元素是不是popA的第一个元素。</p>
<p>② 如果不是，则继续将pushA的下一个元素压入栈中，回到①；</p>
<p>③ 如果是，栈中元素出栈，回到①。</p>
<p>直到pushA所有元素都入栈。</p>
<p>最后判断栈中是否还有元素，没有的话说明出栈序列合法。</p>
<h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><hr>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">IsPopOrder</span><span class="params">(<span class="keyword">int</span> [] pushA,<span class="keyword">int</span> [] popA)</span> </span>{</span><br><span class="line">		<span class="keyword">if</span>(pushA.length != popA.length||</span><br><span class="line">          pushA.length == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        Stack&lt;Integer&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> index=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j : pushA){</span><br><span class="line">            stack.push(pushA[j]);</span><br><span class="line">            <span class="keyword">while</span>(!stack.isEmpty() &amp;&amp; stack.peek() == popA[i]){</span><br><span class="line">                stack.pop();</span><br><span class="line">                i++;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> stack.isEmpty();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>剑指OFFER</tag>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title>Java集合（三）</title>
    <url>/post/6ddde32.html</url>
    <content><![CDATA[<h1 id="Queue集合"><a href="#Queue集合" class="headerlink" title="Queue集合"></a>Queue集合</h1><hr>
<p>Queue接口及其子系：</p>
<p><img src="https://gitee.com/man-ljw/PicBed/raw/master/QQ%E6%88%AA%E5%9B%BE20210711172706.jpg" alt=""></p>
<a id="more"></a>

<p><strong>常用方法：</strong></p>
<table>
<thead>
<tr>
<th align="center">函数</th>
<th align="center">功能</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>void add(Object o)</code></td>
<td align="center">将指定元素添加到队尾，通过调用offer(Object o)，<font style="color: red">非空</font></td>
</tr>
<tr>
<td align="center"><code>Object element()</code></td>
<td align="center">获取队列头部元素，但不删除</td>
</tr>
<tr>
<td align="center"><code>boolean offer(Object)</code></td>
<td align="center">将指定元素添加到队尾。<br>容量有限时，此方法更好。</td>
</tr>
<tr>
<td align="center"><code>Object peek()</code></td>
<td align="center">获取头部元素，但不删除</td>
</tr>
<tr>
<td align="center"><code>Object poll()</code></td>
<td align="center">获取头部元素，<font style="color: red">并删除</font></td>
</tr>
<tr>
<td align="center"><code>Object remove()</code></td>
<td align="center">获取头部元素，<font style="color: red">并删除</font></td>
</tr>
</tbody></table>
<br>

<h2 id="PriorityQueue实现类"><a href="#PriorityQueue实现类" class="headerlink" title="PriorityQueue实现类"></a>PriorityQueue实现类</h2><hr>
<p>并不是绝对标准的队列实现：插入元素会进行<font style="color: red">排序</font>，队列中保存的顺序按照<strong>队列中元素的大小</strong>，所以<code>poll()</code>或者<code>peek()</code>得到的是最小元素。也就是说PriorityQueue并不遵循<strong>FIFO</strong>。</p>
<p><strong>不允许插入null元素。</strong></p>
<p>排序也有两种方法：自然排序和定制排序。（想到了TreeSet）</p>
<h3 id="自然排序"><a href="#自然排序" class="headerlink" title="自然排序"></a>自然排序</h3><p>插入到PriorityQueue的元素都必须实现了<strong>comparable</strong>接口。</p>
<h3 id="定制排序"><a href="#定制排序" class="headerlink" title="定制排序"></a>定制排序</h3><p>创建PriorityQueue时传入<strong>comparator</strong>对象。</p>
<br>



<h2 id="Deque接口"><a href="#Deque接口" class="headerlink" title="Deque接口"></a>Deque接口</h2><hr>
<p>Deque是Queue接口的子接口，代表一个<strong>双端队列</strong>。</p>
<p>默认长度是16，每次扩容<font style="color: red">2倍</font>。</p>
<h3 id="ArrayDeque实现类"><a href="#ArrayDeque实现类" class="headerlink" title="ArrayDeque实现类"></a>ArrayDeque实现类</h3><p>是一个基于数组实现的双端队列。</p>
<p><strong>特有方法：</strong></p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">pop</span><span class="params">()</span></span>;<span class="comment">//删除并返回头部元素，通过removeFirst函数</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">removeFirst</span><span class="params">()</span></span>;<span class="comment">//删除头部元素并返回</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">removeLast</span><span class="params">()</span></span>;<span class="comment">//删除尾部元素并返回</span></span><br></pre></td></tr></tbody></table></figure>

<p><strong>ArrayDeque</strong>的功能和Stack类似，但性能比Stack更优秀。</p>
<br>



<h2 id="LinkedList实现类"><a href="#LinkedList实现类" class="headerlink" title="LinkedList实现类"></a>LinkedList实现类</h2><hr>
<p>LinkedList是List接口的实现类，所i有可以通过索引访问。此外还实现了Deque接口，因此可以当作双端口队列来使用—&gt;”栈“。</p>
<p>对比前面的ArrayList，基于双向链表实现，他俩的区别就是数组和链表的区别：</p>
<p>ArrayList可以随机访问 ，但是插入删除的代价很高。</p>
<p>LinkedList可以轻松的完成插入删除的工作，但不支持随机访问。</p>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Vector补充</title>
    <url>/post/d5599252.html</url>
    <content><![CDATA[<h2 id=""><a href="#" class="headerlink" title=""></a></h2><p>前面只说了vector是线程安全的。下面是对其部分源码的解读。</p>
<h2 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h2><hr>
<p><img src="https://gitee.com/man-ljw/PicBed/raw/master/image-20210711125545819.png" alt=""></p>
<ol>
<li><p>Vector(int initialCapacity, int capacityIncrement)</p>
<p>initialCapacity是Vector初始长度，capacityIncrement是在当前长度不够进行扩容时的扩容长度。</p>
</li>
<li><p>Vector(int)<br>只声明了初始长度，capacityIncrement是0。</p>
</li>
<li><p>Vector()<br>默认长度是10。</p>
</li>
<li><p>Vector(Collection )</p>
<p>将Collection转为Vector。</p>
</li>
</ol>
<h2 id="add"><a href="#add" class="headerlink" title="add"></a>add</h2><hr>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>{</span><br><span class="line">    modCount++;</span><br><span class="line">    ensureCapacityHelper(elementCount + <span class="number">1</span>);</span><br><span class="line">    elementData[elementCount++] = e;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>使用<code>synchronized</code>进行同步，返回true。</p>
<p>对比另一个addElement函数，区别是没有返回值</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">addElement</span><span class="params">(E obj)</span> </span>{</span><br><span class="line">    modCount++;</span><br><span class="line">    ensureCapacityHelper(elementCount + <span class="number">1</span>);</span><br><span class="line">    elementData[elementCount++] = obj;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>



<h2 id="扩容"><a href="#扩容" class="headerlink" title="扩容"></a>扩容</h2><p>和ArrayList类似的。</p>
<p>不过如果不指定capacityIncrement的话，扩容后是原来的<strong>2倍</strong>，而不像ArrayList的1.5倍。</p>
<p>2倍空间不够的话，就直接给所需要的最短长度。</p>
<p>最大值长度也是2<sup>31</sup>-1，即Integer.MAX_VALUE。</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The maximum size of array to allocate.</span></span><br><span class="line"><span class="comment"> * Some VMs reserve some header words in an array.</span></span><br><span class="line"><span class="comment"> * Attempts to allocate larger arrays may result in</span></span><br><span class="line"><span class="comment"> * OutOfMemoryError: Requested array size exceeds VM limit</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_ARRAY_SIZE = Integer.MAX_VALUE - <span class="number">8</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">grow</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>{</span><br><span class="line">    <span class="comment">// overflow-conscious code</span></span><br><span class="line">    <span class="keyword">int</span> oldCapacity = elementData.length;</span><br><span class="line">    <span class="keyword">int</span> newCapacity = oldCapacity + ((capacityIncrement &gt; <span class="number">0</span>) ?</span><br><span class="line">                                     capacityIncrement : oldCapacity);</span><br><span class="line">    <span class="keyword">if</span> (newCapacity - minCapacity &lt; <span class="number">0</span>)</span><br><span class="line">        newCapacity = minCapacity;</span><br><span class="line">    <span class="keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="number">0</span>)</span><br><span class="line">        newCapacity = hugeCapacity(minCapacity);</span><br><span class="line">    elementData = Arrays.copyOf(elementData, newCapacity);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>



<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>JZ29 最小的K个数</title>
    <url>/post/35b4acc4.html</url>
    <content><![CDATA[<p><a href="https://www.nowcoder.com/practice/6a296eb82cf844ca8539b57c23e6e9bf?tpId=13&amp;&amp;tqId=11182&amp;rp=1&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking" target="_blank" rel="noopener">原题链接</a></p>
<br>

<h2 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h2><hr>
<p>给定一个数组，找出其中最小的K个数。例如数组元素是4,5,1,6,2,7,3,8这8个数字，则最小的4个数字是1,2,3,4。</p>
<p>0 &lt;= k &lt;= input.length &lt;= 10000；</p>
<p>0 &lt;= input[i] &lt;= 10000。</p>
<a id="more"></a><br>

<h2 id="示例1"><a href="#示例1" class="headerlink" title="示例1"></a>示例1</h2><figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">输入：[4,5,1,6,2,7,3,8],4 </span><br><span class="line">返回值：[1,2,3,4]</span><br><span class="line">说明：返回最小的4个数即可，返回[1,3,2,4]也可以</span><br></pre></td></tr></tbody></table></figure>

<br>

<h2 id="示例2"><a href="#示例2" class="headerlink" title="示例2"></a>示例2</h2><figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">输入：[1], 0</span><br><span class="line">返回值：[]</span><br></pre></td></tr></tbody></table></figure>

<br>

<h2 id="示例3"><a href="#示例3" class="headerlink" title="示例3"></a>示例3</h2><figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">输入：[0,1,2,1,2],3</span><br><span class="line">返回值：[0,1,1]</span><br></pre></td></tr></tbody></table></figure>

<br>

<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>一、最简单的办法，把input[]元素全部插入PriorityQueue中进行自动排序，然后k次poll()出队首元素，这样时间复杂度是。</p>
<p>二、用<strong>堆</strong>的方法</p>
<p>三、分治。</p>
<h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><h3 id="一、简单"><a href="#一、简单" class="headerlink" title="一、简单"></a>一、简单</h3><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.PriorityQueue;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ArrayList&lt;Integer&gt; <span class="title">GetLeastNumbers_Solution</span><span class="params">(<span class="keyword">int</span> [] input, <span class="keyword">int</span> k)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span>(input.length==<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> ArrayList&lt;&gt;(<span class="number">0</span>);</span><br><span class="line">        PriorityQueue&lt;Integer&gt; priorityQueue = <span class="keyword">new</span> PriorityQueue&lt;&gt;(input.length);</span><br><span class="line">        ArrayList&lt;Integer&gt; arrayList = <span class="keyword">new</span> ArrayList&lt;&gt;(<span class="number">4</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;input.length;i++){</span><br><span class="line">            priorityQueue.add(input[i]);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;k;i++){</span><br><span class="line">            arrayList.add(priorityQueue.poll());</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> arrayList;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">        <span class="keyword">int</span>[] arr = {<span class="number">4</span>,<span class="number">5</span>,<span class="number">1</span>,<span class="number">6</span>,<span class="number">2</span>,<span class="number">7</span>,<span class="number">3</span>,<span class="number">8</span>};</span><br><span class="line"></span><br><span class="line">        System.out.println(GetLeastNumbers_Solution(arr, <span class="number">4</span>));</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<br>

<h3 id="二、堆"><a href="#二、堆" class="headerlink" title="二、堆"></a>二、堆</h3><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">还没写。</span><br></pre></td></tr></tbody></table></figure>

<br>

<h3 id="三、分治"><a href="#三、分治" class="headerlink" title="三、分治"></a>三、分治</h3><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">没写。</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">import java.util.ArrayList;</span><br><span class="line">import java.util.PriorityQueue;</span><br><span class="line"></span><br><span class="line">public class Solution {</span><br><span class="line">    public static ArrayList&lt;Integer&gt; GetLeastNumbers_Solution(int[] nums, int k) {</span><br><span class="line">        ArrayList&lt;Integer&gt; ret = new ArrayList&lt;&gt;();</span><br><span class="line">        if (k &gt; nums.length || k &lt;= 0)</span><br><span class="line">            return ret;</span><br><span class="line">        findKthSmallest(nums, k - 1);</span><br><span class="line">        /* findKthSmallest 会改变数组，使得前 k 个数都是最小的 k 个数 */</span><br><span class="line">        for (int i = 0; i &lt; k; i++)</span><br><span class="line">            ret.add(nums[i]);</span><br><span class="line">        return ret;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    public static void findKthSmallest(int[] nums, int k) {</span><br><span class="line">        int l = 0, h = nums.length - 1;</span><br><span class="line">        while (l &lt; h) {</span><br><span class="line">            int j = partition(nums, l, h);</span><br><span class="line">            if (j == k)</span><br><span class="line">                break;</span><br><span class="line">            if (j &gt; k)</span><br><span class="line">                h = j - 1;</span><br><span class="line">            else</span><br><span class="line">                l = j + 1;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    private static int partition(int[] nums, int l, int h) {</span><br><span class="line">        int p = nums[l];     /* 切分元素 */</span><br><span class="line">        int i = l, j = h + 1;</span><br><span class="line">        while (true) {</span><br><span class="line">            while (i != h &amp;&amp; nums[++i] &lt; p) ;</span><br><span class="line">            while (j != l &amp;&amp; nums[--j] &gt; p) ;</span><br><span class="line">            if (i &gt;= j)</span><br><span class="line">                break;</span><br><span class="line">            swap(nums, i, j);</span><br><span class="line">        }</span><br><span class="line">        swap(nums, l, j);</span><br><span class="line">        return j;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    private static void swap(int[] nums, int i, int j) {</span><br><span class="line">        int t = nums[i];</span><br><span class="line">        nums[i] = nums[j];</span><br><span class="line">        nums[j] = t;</span><br><span class="line">    }</span><br></pre></td></tr></tbody></table></figure><script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>剑指OFFER</tag>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title>Java集合（四）</title>
    <url>/post/b1f0c757.html</url>
    <content><![CDATA[<h1 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h1><hr>
<p>Map系：粗线框代表接口。</p>
<p><img src="https://gitee.com/man-ljw/PicBed/raw/master/newMap.png" alt=""></p>
<a id="more"></a>

<h2 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h2><hr>
<p>几乎所有实体类都继承了AbstractMap，唯独Hashtable没有，它也是唯一线程安全的。</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// AbstractMap使实现了Map接口的抽象类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>{}</span><br><span class="line"></span><br><span class="line"><span class="comment">//Hashtable没有继承AbstractMap</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Hashtable</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">extends</span> <span class="title">Dictionary</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">Map</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;, <span class="title">Cloneable</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializab</span></span>{}</span><br><span class="line"></span><br><span class="line"><span class="comment">//WeakHashMap继承了AbstractMap</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WeakHashMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">extends</span> <span class="title">AbstractMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">Map</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>{</span><br><span class="line"></span><br><span class="line"><span class="comment">//EnumMap继承了AbstractMap</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EnumMap</span>&lt;<span class="title">K</span> <span class="keyword">extends</span> <span class="title">Enum</span>&lt;<span class="title">K</span>&gt;, <span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractMap</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt;</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">//<span class="title">IdentityHashMap</span>继承了<span class="title">AbstractMap</span>  </span></span><br><span class="line"><span class="class"><span class="title">public</span> <span class="title">class</span> <span class="title">IdentityHashMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">extends</span> <span class="title">AbstractMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">Map</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span>, <span class="title">Cloneable</span></span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">//<span class="title">TreeMap</span>继承了<span class="title">AbstractMap</span></span></span><br><span class="line"><span class="class"><span class="title">public</span> <span class="title">class</span> <span class="title">TreeMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">extends</span> <span class="title">AbstractMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">NavigableMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;, <span class="title">Cloneable</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span></span>{}</span><br></pre></td></tr></tbody></table></figure>

<br>

<h2 id="基本概述"><a href="#基本概述" class="headerlink" title="基本概述"></a>基本概述</h2><hr>
<p>每一个Map元素包括两个值，一个是key另一个是value，二者存在映射关系，也就是可以通过key索引得到唯一对应的value。所以Map中<strong>key不允许重复</strong>，key的相等与否通过<code>equals()</code>方法确定，key和value都是任何引用类型的数据。</p>
<p>Map中的key在一起就组成了一个Set集合（无序、不重复），并且Map提供了keySet()方法，用于返回所有key组成的Set集合。</p>
<p>Map和Set有很多相似的地方，如果把Map中存储的Key-Value对称一个变量，并且value是key的附庸，key在哪里valuse就在哪里的话，Map和Set就没有什么区别了。而如果把所有的value放在一起来看，Map又像是一个List（可重复，key看作索引）。</p>
<br>



<h2 id="提供的方法"><a href="#提供的方法" class="headerlink" title="提供的方法"></a>提供的方法</h2><hr>
<table>
<thead>
<tr>
<th align="center">方法</th>
<th align="center">功能</th>
</tr>
</thead>
<tbody><tr>
<td align="center">void  clear()</td>
<td align="center">清空Map</td>
</tr>
<tr>
<td align="center">booelan containsKey(Object key)</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">booelan containsValue(Object key)</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">Set entrySet()</td>
<td align="center">返回key-value对组成的Set集合；</td>
</tr>
<tr>
<td align="center">Object get(Object key)</td>
<td align="center">获取key对应的value，不存在则返回null</td>
</tr>
<tr>
<td align="center">boolean isEmpty()</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">Set keySet()</td>
<td align="center">返回所有key组成的Set集合</td>
</tr>
<tr>
<td align="center">Object put(Object key, Object value)</td>
<td align="center">添加一对值，如果已有key相同的，覆盖</td>
</tr>
<tr>
<td align="center">void putAll(Map m)</td>
<td align="center">将m中的全部kv对复制到本map中</td>
</tr>
<tr>
<td align="center">Object remove(Objecct key)</td>
<td align="center">删除kv对，返回value，key不存在返回null</td>
</tr>
<tr>
<td align="center">int size()</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">Collection values()</td>
<td align="center">返回该map中所有value组成的Collection</td>
</tr>
</tbody></table>
<p>Map中包含一个内部类：Entry，封装了key-value对。有以下三个方法：</p>
<p>getKey(), getValue() 以及setValue()。</p>
<br>

<h2 id="HaspMap"><a href="#HaspMap" class="headerlink" title="HaspMap"></a>HaspMap</h2><hr>
<h3 id="存储结构"><a href="#存储结构" class="headerlink" title="存储结构"></a>存储结构</h3><p>HashMap内部数据结构：数组+单链表。</p>
<p>数组为了索引访问，单链表为了HashCode相等但是equals返回false的问题。（和HashSet很像）</p>
<p>如下图：（<a href="https://github.com/CyC2018/CS-Notes" target="_blank" rel="noopener">图源</a>）</p>
<p>table[0] 指定用于存储key = null的键值对。</p>
<p>数组的容量一定是2^n^，即使在创建时传入的参数不是2^n^HashMap也会将其向上转换。</p>
<p><img src="https://gitee.com/man-ljw/PicBed/raw/master/HashMap%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84.jpg" alt=""></p>
<h3 id="插入及扩容"><a href="#插入及扩容" class="headerlink" title="插入及扩容"></a>插入及扩容</h3><p>创建HashMap的默认大小是16。在向HashMap添加kv对时，和HashSet一样，hashCode决定下标。</p>
<p>数组中的每一个位置被称作一个<strong>桶</strong>，桶中除了存放key，value外，还有自己的哈希值以及一个链表Entry。同一个链表中存放<strong>哈希值</strong>和<strong>散列桶</strong>取模运算(就是hashCode%capacity)结果相同的 Entry。如果HashCode相同，equals返回false时，新来的元素会被放置到对应桶中并插在原元素之前，也就是说，这里的链表插入方法在 JDK1.7用的是头插法，而JDK1.8及之后使用的都是尾插法。。<font style="color:red">数组长度大于64，并且一个桶存储的链表长度大于等于 8 时会将链表转换为红黑树</font>。</p>
<p>设 HashMap 的 table 长度为 M，需要存储的键值对数量为 N，如果哈希函数满足均匀性的要求，那么每条链表的长度大约为 N/M，因此查找的复杂度为 O(N/M)。为了让查找的成本降低，应该使 N/M 尽可能小，因此需要保证 M 尽可能大，也就是说 table 要尽可能大。HashMap 采用动态扩容来根据当前的 N 值来调整 M 值，使得空间效率和时间效率都能得到保证。</p>
<p>HashMap的扩容有些特殊，一般容器是装满了才进行扩容，但HashMap不是。它有一个<code>LOAD_FACTOR</code>就是装载因子（小于1）来限制HashMap的装载量（maxLoad = capacity * LOAD_FACTOR），也就是说它里面的元素个数是达不到最大容量的。具体原因参考了<a href="https://blog.csdn.net/q85647842" target="_blank" rel="noopener">躺沙滩上等死的博文</a>。</p>
<p>在需要扩容时默认扩容后是原来的<font style="color:red">2倍</font>，然后将旧容器的所有键值对重新插入新容器。</p>
<br>



<h2 id="HashMap和Hashtable"><a href="#HashMap和Hashtable" class="headerlink" title="HashMap和Hashtable"></a>HashMap和Hashtable</h2><hr>
<p>二者都是Map的实现类，区别主要是：</p>
<ol>
<li>Hashtable是一个**线程安全的Map实现，而HashMap是线程不安全的；所以HashMap性能会高一点。</li>
<li>Hashtable不允许使用null作为key或value，但HashMap允许。</li>
</ol>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.klaus.maps;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MapTest</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">        Map&lt;Integer,String&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        System.out.println(map.put(<span class="number">1</span>, <span class="string">"a"</span>)); <span class="comment">// null</span></span><br><span class="line">        System.out.println(map.put(<span class="number">2</span>, <span class="string">"b"</span>));<span class="comment">// null</span></span><br><span class="line">        System.out.println(map.put(<span class="number">1</span>, <span class="string">"x"</span>));<span class="comment">// a</span></span><br><span class="line"></span><br><span class="line">        System.out.println(map);<span class="comment">// {1=x, 2=b}</span></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>注释的内容是输出结果，正常添加是返回的都是null，而在添加失败时<font style="color:red">返回key已对应value</font>。</p>
<h3 id="HashMap的迭代方法"><a href="#HashMap的迭代方法" class="headerlink" title="HashMap的迭代方法"></a>HashMap的迭代方法</h3><p>Map接口并没有获取Iterator的方法，并且Iterator只适用于Collection，所以说只能获取key的Set集合然后再调用iterator()方法获得迭代器。</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">//获取迭代器</span></span><br><span class="line">Iterator&lt;String&gt; iterator = map.keySet().iterator();</span><br><span class="line"><span class="keyword">while</span> (iterator.hasNext()){</span><br><span class="line">    System.out.println(map.get(iterator.next()));</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h3 id="判等原则"><a href="#判等原则" class="headerlink" title="判等原则"></a>判等原则</h3><p>HashMap和Hashtable都是<font style="color:red">只根据equals()的返回结果来去确定</font></p>
<p>自定义类做key的时候，如果重写equals()和hashCode()方法，就应该保证equals()的结果和hashCode()的结果是一致的，即：equals()返回true时，hashCode()的值应该相等。</p>
<p>对比hashSet，判等不仅要求equals()返回true，还要hashCode()相等。</p>
<h3 id="LinkedHashMap"><a href="#LinkedHashMap" class="headerlink" title="LinkedHashMap"></a>LinkedHashMap</h3><p>这是HashMap的子类，与LinkedHashSet类似，它也是用<strong>双向链表</strong>维护Map，可以记住添加顺序。</p>
<h3 id="IdentityHashMap"><a href="#IdentityHashMap" class="headerlink" title="IdentityHashMap"></a>IdentityHashMap</h3><p>判等方法不同，IdentityHashMap根据==结果判断。</p>
<br>

<h2 id="TreeMap"><a href="#TreeMap" class="headerlink" title="TreeMap"></a>TreeMap</h2><hr>
<p>TreeMap实现了Map接口的子接口SortedMap，本身是一个<font style="color:red"> 红黑树</font>，每一个键值对是树上的一个结点。TreeMap插入结点时会根据key进行排序。和TreeSet类似，排序同样有自然排序、定制排序两种。</p>
<ul>
<li>自然排序：所有key必须实现Comparable接口，并且key应该时同一个类的对象</li>
<li>定制排序：创建TreeMap时传入Comparator对象。</li>
</ul>
<h3 id="判等规则"><a href="#判等规则" class="headerlink" title="判等规则"></a>判等规则</h3><p>key通过compareTo()方法比较返回0，则相等。</p>
<p>自定义类做key的时候，应该重写equals()和compareTo()方法，保证equals()的返回true时compareTo()的结果是0。</p>
<h3 id="基本方法"><a href="#基本方法" class="headerlink" title="基本方法"></a>基本方法</h3><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**** 最大最小值 ****/</span></span><br><span class="line"><span class="comment">//返回key最小的键值对</span></span><br><span class="line">Map.<span class="function">Entry <span class="title">firstEntry</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">//返回最小键值</span></span><br><span class="line"><span class="function">Object <span class="title">firstKey</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">//返回key最大的键值对</span></span><br><span class="line">Map.<span class="function">Entry <span class="title">lastEntry</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">//返回最大键值</span></span><br><span class="line"><span class="function">Object <span class="title">lastKey</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**** 大于某一key的最小值，小于某一key的最大值 ****/</span></span><br><span class="line"><span class="comment">//返回键值大于key的最小Entry</span></span><br><span class="line">Map.<span class="function">Entry <span class="title">higherEntry</span><span class="params">(Object key)</span></span>;</span><br><span class="line"><span class="comment">//返回键值大于key的最小key</span></span><br><span class="line"><span class="function">Object <span class="title">higherKey</span><span class="params">(Object key)</span></span>;</span><br><span class="line"><span class="comment">//对应的lower一样</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**** 子Map ****/</span></span><br><span class="line"><span class="function">NavigableMap <span class="title">subMap</span><span class="params">(Object fromKey, <span class="keyword">boolean</span> fromInclusive, Object toKey, <span class="keyword">boolean</span> toInclusive)</span></span>;</span><br><span class="line"><span class="comment">//返回子Map，键值从fromKey到toKey，是否包含这两个边界元素取决于对应的boolean参数</span></span><br><span class="line"><span class="function">SortedMap <span class="title">subMap</span><span class="params">(Object fromKey, Object toKey)</span></span>;</span><br><span class="line"><span class="comment">//返回子Map，Key属于[fromKey, toKey)</span></span><br><span class="line"><span class="function">SortedMap <span class="title">tailMap</span><span class="params">(Object fromKey)</span></span>;</span><br><span class="line"><span class="comment">//返回子Map，key的范围大于fromKey</span></span><br></pre></td></tr></tbody></table></figure>

<br>

<h2 id="WeakHashMap"><a href="#WeakHashMap" class="headerlink" title="WeakHashMap"></a>WeakHashMap</h2><hr>
<blockquote>
<p>HashMap的key保留了堆实际对象的<strong>强引用类型</strong>，这意味着只要该HashMap对象不被删除，key引用的对象就不会被回收，HashMap也不会自动清理这些键值对；而WeakHashMap保留的是弱引用，只要WeakHashMap对象中key引用的对象不被强引用变量引用，那这些key所引用的对象可能被垃圾回收，WeakHashMap也可能自动删除key对应的键值对。</p>
<p>—《疯狂Java讲义 第2版》</p>
</blockquote>
<p>例：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.klaus.maps;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.WeakHashMap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WeakHashMapTest</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">        WeakHashMap&lt;String , String&gt; whm = <span class="keyword">new</span> WeakHashMap&lt;&gt;();</span><br><span class="line">        whm.put(<span class="keyword">new</span> String(<span class="string">"语文"</span>), <span class="keyword">new</span> String(<span class="string">"良好"</span>));</span><br><span class="line">        whm.put(<span class="keyword">new</span> String(<span class="string">"数学"</span>), <span class="keyword">new</span> String(<span class="string">"一般"</span>));</span><br><span class="line">        whm.put(<span class="string">"Java"</span>, <span class="keyword">new</span> String(<span class="string">"良好"</span>));</span><br><span class="line"></span><br><span class="line">        System.out.println(whm);</span><br><span class="line">        System.gc();</span><br><span class="line">        System.runFinalization();</span><br><span class="line">        System.out.println(whm);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>它的输出是</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">{Java=良好, 数学=一般, 语文=良好}</span><br><span class="line">{Java=良好}</span><br></pre></td></tr></tbody></table></figure>

<p>因为“Java”的添加方式是key作为<strong>字符串直接量</strong>，垃圾回收时不会回收它。</p>
<p>WeakHashMap 主要用来实现缓存，Tomcat 中的 ConcurrentCache 使用了 WeakHashMap 来实现缓存功能。</p>
<h1 id="性能分析"><a href="#性能分析" class="headerlink" title="性能分析"></a>性能分析</h1><p>HashMap略快与Hashtable；</p>
<p>TreeMap通常慢于上面的，尤其在增、删时（因为采用红黑树）；</p>
<p>LinkedHashMap比HashMap慢，因为需要维护链表保持添加顺序，使用==判等0。</p>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>==和equals()方法的区别</title>
    <url>/post/7e168472.html</url>
    <content><![CDATA[<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">    String a = <span class="string">"a"</span>;</span><br><span class="line">    String b = <span class="keyword">new</span> String(<span class="string">"a"</span>);</span><br><span class="line">    String c = <span class="keyword">new</span> String(<span class="string">"a"</span>);</span><br><span class="line">    String d =c;</span><br><span class="line"></span><br><span class="line">    System.out.println(a==b);<span class="comment">//false</span></span><br><span class="line">    System.out.println(a.equals(b));<span class="comment">//true</span></span><br><span class="line">    System.out.println(b==c);<span class="comment">//false</span></span><br><span class="line">    System.out.println(b.equals(c));<span class="comment">//true</span></span><br><span class="line">    System.out.println(c==d);<span class="comment">//true</span></span><br><span class="line">    System.out.println(c.equals(d));<span class="comment">//true</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>个人理解，==就是直接判断两个变量指示的值是否相等，对普通变量而言足够了，但是java中还有一种变量叫做<strong>引用变量</strong>，对一个String类型的引用变量b来说，a直接指向了“a”，而b指向的是new出来的String对象所在的<strong>地址</strong>，直接使用==比较就相当于拿”a”和一串内存地址作比较，所以a==b是false。而equals()方法则会根据地址，找到地址指向的内容，然后进行比较。</p>
<p>然后直接的<code>String d =c;</code>是个浅拷贝。</p>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>JZ63 数据流中的中位数</title>
    <url>/post/6b3afdd4.html</url>
    <content><![CDATA[<p><a href="https://www.nowcoder.com/practice/9be0172896bd43948f8a32fb954e1be1?tpId=13&amp;&amp;tqId=11216&amp;rp=1&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking" target="_blank" rel="noopener">原题链接</a></p>
<h2 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h2><p>如何得到一个数据流中的中位数？如果从数据流中读出奇数个数值，那么中位数就是所有数值排序之后位于中间的数值。如果从数据流中读出偶数个数值，那么中位数就是所有数值排序之后中间两个数的平均值。我们使用Insert()方法读取数据流，使用GetMedian()方法获取当前读取数据的中位数。<a id="more"></a></p>
<h2 id="示例1"><a href="#示例1" class="headerlink" title="示例1"></a>示例1</h2><figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">输入：[5,2,3,4,1,6,7,0,8]</span><br><span class="line">返回值："5.00 3.50 3.00 3.50 3.00 3.50 4.00 3.50 4.00 "</span><br><span class="line">说明：数据流里面不断吐出的是5,2,3...,则得到的平均数分别为5,(5+2)/2,3...</span><br></pre></td></tr></tbody></table></figure>

<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>这道题看示例反而看得更迷糊了。简单的叙述一下就是：这里会动态的插入若干数值，然后会边插边求中位数。</p>
<p>目前我能想到两种方法。一是用数组存储插入的数值，然后进行排序挑选中位数；二是<strong>插入排序</strong>，最后GetMedian()部分只需要根据奇偶个数返回中位数就可以了。</p>
<h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><h3 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h3><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Vector;</span><br><span class="line"><span class="keyword">import</span> java.util.Collections;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>{</span><br><span class="line">    Vector&lt;Integer&gt; vector = <span class="keyword">new</span> Vector&lt;&gt;();</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Insert</span><span class="params">(Integer num)</span> </span>{</span><br><span class="line">        vector.add(num);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Double <span class="title">GetMedian</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">int</span> len = vector.size();</span><br><span class="line">        Collections.sort(vector);</span><br><span class="line">        <span class="keyword">if</span>(len%<span class="number">2</span> == <span class="number">0</span>){</span><br><span class="line">            <span class="keyword">double</span> res = ((<span class="keyword">double</span>)vector.get(len / <span class="number">2</span>) + (<span class="keyword">double</span>)vector.get(len / <span class="number">2</span> - <span class="number">1</span>))/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        }<span class="keyword">else</span>{</span><br><span class="line">            <span class="keyword">double</span> res =(<span class="keyword">double</span>) vector.get(len / <span class="number">2</span>);</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>这里提醒自己，太久没碰java以至于原来写出来<code>double res = (vector.get(len / 2) + vector.get(len / 2 - 1))/2;</code>这样的代码，最后返回的总是一个整数。就是那个折磨，，法二明天写吧。</p>
<h2 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h2><p>利用ArrayList作为容器进行插入排序。</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>{</span><br><span class="line">    ArrayList&lt;Integer&gt; arrayList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span>  <span class="keyword">void</span> <span class="title">Insert</span><span class="params">(Integer num)</span></span>{</span><br><span class="line">        <span class="keyword">if</span> (arrayList.isEmpty())</span><br><span class="line">            arrayList.add(num);</span><br><span class="line">        <span class="keyword">else</span> {</span><br><span class="line">            Iterator iterator = arrayList.iterator();</span><br><span class="line">            <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (iterator.hasNext()){</span><br><span class="line">                <span class="keyword">if</span> (num &gt; (Integer) iterator.next()) {</span><br><span class="line">                    index++;</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">            arrayList.add(index, num);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Double <span class="title">GetMedian</span><span class="params">()</span></span>{</span><br><span class="line">        <span class="keyword">int</span> len = arrayList.size();</span><br><span class="line">        <span class="keyword">if</span> ((len&amp;<span class="number">1</span>)==<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> ((<span class="keyword">double</span>)arrayList.get(len/<span class="number">2</span>) + (<span class="keyword">double</span>) arrayList.get(len/ <span class="number">2</span> -<span class="number">1</span>))/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">double</span>)arrayList.get(len/<span class="number">2</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>剑指OFFER</tag>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title>JZ64 滑动窗口的最大值</title>
    <url>/post/6aa97155.html</url>
    <content><![CDATA[<p><a href="https://www.nowcoder.com/practice/1624bc35a45c42c0bc17d17fa0cba788?tpId=13&amp;tqId=11217&amp;tPage=1&amp;rp=1&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking&amp;from=cyc_github" target="_blank" rel="noopener">原题链接</a></p>
<h2 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h2><p>给定一个数组和滑动窗口的大小，找出所有滑动窗口里数值的最大值。</p>
<p>例如，如果输入数组{2,3,4,2,6,2,5,1}及滑动窗口的大小3，那么一共存在6个滑动窗口，他们的最大值分别为{4,4,6,6,6,5}； 针对数组{2,3,4,2,6,2,5,1}的滑动窗口有以下6个： {[2,3,4],2,6,2,5,1}， {2,[3,4,2],6,2,5,1}， {2,3,[4,2,6],2,5,1}， {2,3,4,[2,6,2],5,1}， {2,3,4,2,[6,2,5],1}， {2,3,4,2,6,[2,5,1]}。</p>
<p>窗口大于数组长度的时候，返回空。</p>
<h2 id="示例1"><a href="#示例1" class="headerlink" title="示例1"></a>示例1</h2><figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">输入：[2,3,4,2,6,2,5,1],3</span><br><span class="line">返回值：[4,4,6,6,6,5]</span><br></pre></td></tr></tbody></table></figure>

<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>最后的返回空是[]不是null。</p>
<p>又要用到堆，可是我还没学😓</p>
<h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ArrayList&lt;Integer&gt; <span class="title">maxInWindows</span><span class="params">(<span class="keyword">int</span> [] num, <span class="keyword">int</span> size)</span> </span>{</span><br><span class="line">        <span class="keyword">int</span> len = num.length;</span><br><span class="line">        <span class="keyword">if</span>(size&gt;len || len==<span class="number">0</span>||size ==<span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">new</span> ArrayList&lt;Integer&gt;(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">int</span>[] tmp = <span class="keyword">new</span> <span class="keyword">int</span>[size];<span class="comment">//存储窗口元素</span></span><br><span class="line">        </span><br><span class="line">        ArrayList&lt;Integer&gt; arr= <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i= <span class="number">0</span>;i &lt; len+<span class="number">1</span> -size;i++){</span><br><span class="line">            <span class="keyword">int</span> max = Integer.MIN_VALUE;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt; size;j++){</span><br><span class="line">                tmp[j] = num[i+j];</span><br><span class="line">                <span class="keyword">if</span>(tmp[j] &gt; max)</span><br><span class="line">                    max = tmp[j];</span><br><span class="line">            }</span><br><span class="line">            arr.add(max);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> arr;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>剑指OFFER</tag>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title>JZ42 和为S的两个数字</title>
    <url>/post/70c25d5e.html</url>
    <content><![CDATA[<p><a href="https://www.nowcoder.com/practice/390da4f7a00f44bea7c2f3d19491311b?tpId=13&amp;tqId=11195&amp;tPage=1&amp;rp=1&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking&amp;from=cyc_github" target="_blank" rel="noopener">原题链接</a></p>
<h2 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h2><p>输入一个递增排序的数组和一个数字S，在数组中查找两个数，使得他们的和正好是S，如果有多对数字的和等于S，返回两个数的乘积最小的，如果无法找出这样的数字，返回一个空数组即可。<a id="more"></a></p>
<p><strong>返回值描述：</strong></p>
<p>对应每个测试案例，输出两个数，小的先输出。</p>
<br>

<h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">输入：[1,2,4,7,11,15],15</span><br><span class="line">返回值：[4, 11]</span><br></pre></td></tr></tbody></table></figure>

<br>

<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>数组整体递增排序，然后又要求1. 多对数字的和等于S，返回两个数的乘积最小的，2. 输出两个数，小的先输出。</p>
<p>显然在和一定时，两个加数差距越大，乘积越小，也就是越在前面找到的和为S的数他们的积越小；而数字又是递增排序的，所以只需要存储从0开始遍历array 第一个与后面元素相加和为sum的 数 ，这个数就是所需结果中较小的一对，后面的就不需要再进行了，直接将这个数以及sum-这个数的差添加到arrayList返回，不需要额外空间保存符合条件的数。</p>
<br>

<h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><p><strong>解答一</strong></p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ArrayList&lt;Integer&gt; <span class="title">FindNumbersWithSum</span><span class="params">(<span class="keyword">int</span>[] array, <span class="keyword">int</span> sum)</span> </span>{</span><br><span class="line">        <span class="keyword">int</span> min = Integer.MAX_VALUE;</span><br><span class="line">        ArrayList&lt;Integer&gt; arrayList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> len = array.length;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len - <span class="number">1</span>; i++) {</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = len - <span class="number">1</span>; j &gt; i; j--) {</span><br><span class="line">                <span class="keyword">if</span> (array[i] + array[j] &gt; sum) {</span><br><span class="line">                } <span class="keyword">else</span> <span class="keyword">if</span> (array[i] + array[j] &lt; sum)</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">else</span> {</span><br><span class="line">                    arrayList.add(array[i]);</span><br><span class="line">                    arrayList.add(sum - array[i]);</span><br><span class="line">                    <span class="keyword">return</span> arrayList;</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }        </span><br><span class="line">        <span class="keyword">return</span> arrayList;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<br>

<p><strong>解答二</strong></p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Vector;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ArrayList&lt;Integer&gt; <span class="title">FindNumbersWithSum</span><span class="params">(<span class="keyword">int</span>[] array, <span class="keyword">int</span> sum)</span> </span>{</span><br><span class="line">        Vector&lt;Integer&gt; num1 = <span class="keyword">new</span> Vector&lt;&gt;();</span><br><span class="line">        ArrayList&lt;Integer&gt; arrayList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> len = array.length;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len - <span class="number">1</span>; i++){</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = len-<span class="number">1</span>; j &gt; i; j--){</span><br><span class="line">                <span class="keyword">if</span> (array[i] + array[j] &gt; sum){</span><br><span class="line">                }</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (array[i] + array[j] &lt; sum)</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">else</span> {</span><br><span class="line">                    num1.add(array[i]);</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span> (num1.size()!=<span class="number">0</span>){</span><br><span class="line">            <span class="keyword">int</span> min = num1.get(<span class="number">0</span>);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;num1.size();i++){</span><br><span class="line">                <span class="keyword">if</span> (num1.get(i) &lt; min)</span><br><span class="line">                    min = num1.get(i);</span><br><span class="line">            }</span><br><span class="line">            arrayList.add(min);</span><br><span class="line">            arrayList.add(sum - min);</span><br><span class="line">            <span class="keyword">return</span> arrayList;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> arrayList;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>解答二是原程序，解答一是在写解题思路的时候有了更清楚的认识，然后进行了优化。</p>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>剑指OFFER</tag>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title>堆的使用</title>
    <url>/post/6cd5927f.html</url>
    <content><![CDATA[<p>#</p>
<p>小根堆，根&lt;=左、右</p>
<p>大根堆，根&gt;=左、右</p>
<p>堆存储在数组中，i为下标从0开始：</p>
<ul>
<li><p>i &gt;= int ( n / 2 )，则 i 结点时叶结点</p>
</li>
<li><p>i=0，结点 i 是根节点；否则结点(int) [ ( i - 1 ) / 2 ]是 i 的父节点；</p>
</li>
<li><p>若2 * i + 1 &gt; n - 1，则 i 没有左孩子</p>
</li>
<li><p>若2 * i + 2 &lt; n - 1，则 i 没有右孩子</p>
</li>
</ul>
<h2 id="创建最小堆"><a href="#创建最小堆" class="headerlink" title="创建最小堆"></a>创建最小堆</h2><p>虽然堆是以数组形式存储，它的逻辑结构是树状的。</p>
<p>要将一个普通序列变成最小堆：</p>
<p><img src="https://gitee.com/man-ljw/PicBed/raw/master/QQMail_6.png" alt="">)<img src="https://gitee.com/man-ljw/PicBed/raw/master/QQMail_7.png" alt=""><br><img src="https://gitee.com/man-ljw/PicBed/raw/master/QQMail_8.png" alt=""></p>
<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.klaus.stackAndQueue.prob29;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">checkLeft</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> len)</span></span>{</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span> * i + <span class="number">1</span> &lt; len;</span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">checkRight</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> len)</span></span>{</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span> * i + <span class="number">2</span> &lt; len;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span>[] minHeap(<span class="keyword">int</span>[] arr){</span><br><span class="line">        <span class="keyword">int</span> len = arr.length;</span><br><span class="line">        <span class="keyword">int</span> start = len/<span class="number">2</span> - <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = start; i &gt;<span class="number">0</span>; i--) {</span><br><span class="line">            <span class="keyword">int</span> left,right;</span><br><span class="line">            <span class="comment">//比左结点大</span></span><br><span class="line">            <span class="keyword">if</span> (checkLeft(i, len)){</span><br><span class="line">                <span class="keyword">if</span> (arr[i] &gt; arr[<span class="number">2</span>*i+<span class="number">1</span>] ) {</span><br><span class="line">                    <span class="keyword">int</span> tmp = arr[i];</span><br><span class="line">                    arr[i] = arr[<span class="number">2</span> * i + <span class="number">1</span>];</span><br><span class="line">                    arr[<span class="number">2</span> * i + <span class="number">1</span>] = tmp;</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">            <span class="comment">//比右结点大</span></span><br><span class="line">            <span class="keyword">if</span> (checkRight(i, len)) {</span><br><span class="line">                <span class="keyword">if</span> (arr[i] &gt; arr[<span class="number">2</span> * i + <span class="number">2</span>]) {</span><br><span class="line">                    <span class="keyword">int</span> tmp = arr[i];</span><br><span class="line">                    arr[i] = arr[<span class="number">2</span> * i + <span class="number">2</span>];</span><br><span class="line">                    arr[<span class="number">2</span> * i + <span class="number">2</span>] = tmp;</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">//根</span></span><br><span class="line">        <span class="keyword">int</span> i =<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (checkLeft(i, len) || checkRight(i, len)){</span><br><span class="line">            <span class="keyword">int</span> min = arr[i];</span><br><span class="line">            <span class="keyword">int</span> left=<span class="number">0</span>, right=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (checkLeft(i, len)){</span><br><span class="line">                <span class="keyword">if</span> (arr[i] &gt; arr[<span class="number">2</span>*i +<span class="number">1</span>]) {</span><br><span class="line">                    min = arr[<span class="number">2</span> * i + <span class="number">1</span>];</span><br><span class="line">                    left =<span class="number">1</span>;</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">if</span> (checkRight(i, len)){</span><br><span class="line">                <span class="keyword">if</span> (arr[i] &gt; arr[<span class="number">2</span> * i + <span class="number">2</span>]) {</span><br><span class="line">                    <span class="keyword">if</span> (left == <span class="number">1</span> &amp;&amp; min&lt;arr[<span class="number">2</span> * i + <span class="number">2</span>]){}</span><br><span class="line">                    <span class="keyword">else</span> {</span><br><span class="line">                        min = arr[<span class="number">2</span> * i + <span class="number">2</span>];</span><br><span class="line">                        left=<span class="number">0</span>;</span><br><span class="line">                        right=<span class="number">1</span>;</span><br><span class="line">                    }</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (left ==<span class="number">1</span>){</span><br><span class="line">                <span class="keyword">int</span> tmp = arr[i];</span><br><span class="line">                arr[i] = arr[<span class="number">2</span>*i+<span class="number">1</span>];</span><br><span class="line">                arr[<span class="number">2</span>*i+<span class="number">1</span>] = tmp;</span><br><span class="line">                i = <span class="number">2</span>*i+<span class="number">1</span>;</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (right == <span class="number">1</span>) {</span><br><span class="line">                <span class="keyword">int</span> tmp = arr[i];</span><br><span class="line">                arr[i] = arr[<span class="number">2</span>*i+<span class="number">2</span>];</span><br><span class="line">                arr[<span class="number">2</span>*i+<span class="number">2</span>] = tmp;</span><br><span class="line">                i = <span class="number">2</span>*i+<span class="number">2</span>;</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">return</span> arr;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> arr;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">        <span class="keyword">int</span>[] arr = {<span class="number">53</span>, <span class="number">17</span>, <span class="number">78</span>, <span class="number">9</span>, <span class="number">45</span>, <span class="number">65</span>, <span class="number">87</span>, <span class="number">23</span>};</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span>[] res = minHeap(arr);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i : res)</span><br><span class="line">            System.out.print(i + <span class="string">" "</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
  </entry>
  <entry>
    <title>JZ41 和为S的连续正数序列</title>
    <url>/post/22dc244.html</url>
    <content><![CDATA[<p><a href="https://www.nowcoder.com/practice/c451a3fd84b64cb19485dad758a55ebe?tpId=13&amp;tqId=11194&amp;tPage=1&amp;rp=1&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking&amp;from=cyc_github" target="_blank" rel="noopener">原题链接</a></p>
<hr>
<h2 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h2><p>小明很喜欢数学,有一天他在做数学作业时,要求计算出9~16的和,他马上就写出了正确答案是100。但是他并不满足于此,他在想究竟有多少种连续的正数序列的和为100(至少包括两个数)。没多久,他就得到另一组连续正数和为100的序列:18,19,20,21,22。现在把问题交给你,你能不能也很快的找出所有和为S的连续正数序列? Good Luck!<a id="more"></a></p>
<p><strong>返回值描述</strong></p>
<p>输出所有和为S的连续正数序列。序列内按照从小至大的顺序，序列间按照开始数字从小到大的顺序</p>
<br>



<h2 id="示例1"><a href="#示例1" class="headerlink" title="示例1"></a>示例1</h2><figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">输入：9</span><br><span class="line">返回值：[[2,3,4],[4,5]]</span><br></pre></td></tr></tbody></table></figure>

<br>



<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>一是进行穷举比较容易，但是没有用到<strong>连续序列</strong>的特征。</p>
<p>二是双指针，根据数学知识：结果序列中最大的数就是[n / 2] + 1，所以以此为尾指针的最大值；头指针从1开始。因为是连续序列所以求和公式是：（a<sub>m</sub>+a<sub>n</sub>) * (n - m + 1) / 2，比较求和结果是否等于sum，如果相等 ，把 i 到 j 之间的元素加入，然后尾指针不再递减，因为不会再出现头指针相同尾指针不同的序列使和为sum的序列了；如果和小于sum，那么头指针++，尾指针初始化到末尾重新开始；如果大于sum，尾指针–，进行检测。</p>
<br>



<h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><p><strong>解答一</strong>，穷举法。</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>{</span><br><span class="line">    <span class="keyword">public</span> ArrayList&lt;ArrayList&lt;Integer&gt;&gt; FindContinuousSequence(<span class="keyword">int</span> sum) {</span><br><span class="line">        ArrayList&lt;ArrayList&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (sum ==<span class="number">1</span>)<span class="keyword">return</span> res;</span><br><span class="line">        ArrayList&lt;Integer&gt; tmp;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= sum / <span class="number">2</span> + <span class="number">1</span>; i++) {</span><br><span class="line">            tmp = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">            <span class="keyword">int</span> s = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &lt;= sum / <span class="number">2</span> + <span class="number">1</span>; j++) {</span><br><span class="line">                <span class="keyword">if</span> (s &lt; sum) {</span><br><span class="line">                    s += j;</span><br><span class="line">                    tmp.add(j);</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">if</span> (s == sum)</span><br><span class="line">                res.add(tmp);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p><strong>解答二</strong>，双指针。</p>
<br>



<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>{</span><br><span class="line">    <span class="comment">//双指针</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> ArrayList&lt;ArrayList&lt;Integer&gt;&gt; FindContinuousSequence(<span class="keyword">int</span> sum) {</span><br><span class="line">        ArrayList&lt;ArrayList&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        ArrayList&lt;Integer&gt; arr;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;= sum /<span class="number">2</span>; i++){</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j= sum / <span class="number">2</span> + <span class="number">1</span>; j&gt;i; j--){</span><br><span class="line">                <span class="keyword">if</span> ((i+j)*(j-i+<span class="number">1</span>) /<span class="number">2</span> == sum){</span><br><span class="line">                    arr= <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">                    <span class="keyword">int</span> tmp = i;</span><br><span class="line">                    <span class="keyword">while</span> (tmp&lt;=j)</span><br><span class="line">                        arr.add(tmp++);</span><br><span class="line">                    res.add(arr);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                }<span class="keyword">else</span> <span class="keyword">if</span>((i+j)*(j-i+<span class="number">1</span>) /<span class="number">2</span> &lt; sum)</span><br><span class="line">                    <span class="keyword">break</span>;                </span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>剑指OFFER</tag>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title>JZ44 翻转单词序列</title>
    <url>/post/36bbd715.html</url>
    <content><![CDATA[<p><a href="nowcoder.com/practice/3194a4f4cf814f63919d0790578d51f3?tpId=13&amp;tqId=11197&amp;tPage=1&amp;rp=1&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking&amp;from=cyc_github">原题链接</a></p>
<h2 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h2><hr>
<p>牛客最近来了一个新员工Fish，每天早晨总是会拿着一本英文杂志，写些句子在本子上。同事Cat对Fish写的内容颇感兴趣，有一天他向Fish借来翻看，但却读不懂它的意思。例如，“nowcoder. a am I”。后来才意识到，这家伙原来把句子单词的顺序翻转了，正确的句子应该是“I am a nowcoder.”。Cat对一一的翻转这些单词顺序可不在行，你能帮助他么？<a id="more"></a></p>
<br>

<h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><hr>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">输入："nowcoder. a am I"</span><br><span class="line">返回值："I am a nowcoder."</span><br></pre></td></tr></tbody></table></figure>

<br>

<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>看了这哥的，确实没想到。<a href="https://github.com/CyC2018/CS-Notes/blob/master/notes/58.1%20%E7%BF%BB%E8%BD%AC%E5%8D%95%E8%AF%8D%E9%A1%BA%E5%BA%8F%E5%88%97.md" target="_blank" rel="noopener">点击跳转</a></p>
<blockquote>
<p>先翻转每个单词，再翻转整个字符串。</p>
<p>题目应该有一个隐含条件，就是不能用额外的空间。虽然 Java 的题目输入参数为 String 类型，需要先创建一个字符数组使得空间复杂度为 O(N)，但是正确的参数类型应该和原书一样，为字符数组，并且只能使用该字符数组的空间。任何使用了额外空间的解法在面试时都会大打折扣，包括递归解法。</p>
</blockquote>
<p>我当时想，把传入的String转成char[]，创建一个等长的cahr类型的辅助数组，从原char[]尾部开始用双指针搜索单词，顺序加入到新建的数组中。</p>
<p>这个方法是不需要辅助数组，直接以单词为单位，把从头开始把所有单词逆序，然后再将整个数组逆序。</p>
<br>

<h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">ReverseSentence</span><span class="params">(String str)</span> </span>{</span><br><span class="line">        <span class="keyword">int</span> n = str.length();</span><br><span class="line">        <span class="keyword">char</span>[] chars = str.toCharArray();</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (j &lt;= n) {</span><br><span class="line">            <span class="keyword">if</span> (j == n || chars[j] == <span class="string">' '</span>) {</span><br><span class="line">                reverse(chars, i, j - <span class="number">1</span>);</span><br><span class="line">                i = j + <span class="number">1</span>;</span><br><span class="line">            }</span><br><span class="line">            j++;</span><br><span class="line">        }</span><br><span class="line">        reverse(chars, <span class="number">0</span>, n - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> String(chars);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">reverse</span><span class="params">(<span class="keyword">char</span>[] c, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>{</span><br><span class="line">        <span class="keyword">while</span> (i &lt; j)</span><br><span class="line">            swap(c, i++, j--);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">char</span>[] c, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>{</span><br><span class="line">        <span class="keyword">char</span> t = c[i];</span><br><span class="line">        c[i] = c[j];</span><br><span class="line">        c[j] = t;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>



<h2 id="补"><a href="#补" class="headerlink" title="补"></a>补</h2><p>下面是我根据这个思想自己写的代码</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.klaus.doublePoint.prob44;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">ReverseSentence</span><span class="params">(String str)</span> </span>{</span><br><span class="line">        <span class="keyword">char</span>[] chars = str.toCharArray();</span><br><span class="line">        <span class="keyword">int</span> len = chars.length;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt; len; i++){</span><br><span class="line">            <span class="keyword">if</span> (chars[i] != <span class="string">' '</span>) {<span class="comment">//防止第一个为' '</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &lt; len; j++) {</span><br><span class="line">                    <span class="keyword">if</span> (chars[j] == <span class="string">' '</span>) {</span><br><span class="line">                        reverse(chars, i, j - <span class="number">1</span>);</span><br><span class="line">                        i = j;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    }<span class="keyword">else</span> <span class="keyword">if</span> (j == len -<span class="number">1</span>) {</span><br><span class="line">                        reverse(chars, i, j );</span><br><span class="line">                        i = j;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    }</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        reverse(chars, <span class="number">0</span>, len -<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> String(chars);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">reverse</span><span class="params">(<span class="keyword">char</span>[] chars, <span class="keyword">int</span> from, <span class="keyword">int</span> to)</span></span>{</span><br><span class="line">        <span class="keyword">while</span> (from&lt; to){</span><br><span class="line">            swap(chars, from++, to--);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">char</span>[] chars, <span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>{</span><br><span class="line">        <span class="keyword">char</span> tmp =chars[a];</span><br><span class="line">        chars[a] = chars[b];</span><br><span class="line">        chars[b] = tmp;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h2 id="补2"><a href="#补2" class="headerlink" title="补2"></a>补2</h2><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.klaus.doublePoint.prob44;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">ReverseSentence</span><span class="params">(String str)</span> </span>{</span><br><span class="line">        <span class="keyword">char</span>[] chars = str.toCharArray();</span><br><span class="line">        <span class="keyword">int</span> len = chars.length;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt; len; i++){</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &lt;= len; j++) {</span><br><span class="line">                <span class="keyword">if</span> (j == len || chars[j] == <span class="string">' '</span>) {</span><br><span class="line">                    reverse(chars, i, j - <span class="number">1</span>);</span><br><span class="line">                    i = j;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        reverse(chars, <span class="number">0</span>, len -<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> String(chars);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">reverse</span><span class="params">(<span class="keyword">char</span>[] chars, <span class="keyword">int</span> from, <span class="keyword">int</span> to)</span></span>{</span><br><span class="line">        <span class="keyword">while</span> (from&lt; to){</span><br><span class="line">            swap(chars, from++, to--);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">char</span>[] chars, <span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>{</span><br><span class="line">        <span class="keyword">char</span> tmp =chars[a];</span><br><span class="line">        chars[a] = chars[b];</span><br><span class="line">        chars[b] = tmp;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>剑指OFFER</tag>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title>JZ3 从尾到头打印链表</title>
    <url>/post/cfcb0e04.html</url>
    <content><![CDATA[<p><a href="https://www.nowcoder.com/practice/d0267f7f55b3412ba93bd35cfa8e8035?tpId=13&amp;tqId=11156&amp;tPage=1&amp;rp=1&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking&amp;from=cyc_github" target="_blank" rel="noopener">原题链接</a></p>
<h2 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h2><p>输入一个链表的头节点，按链表从尾到头的顺序返回每个节点的值（用数组返回）。<a id="more"></a></p>
<h2 id="示例1"><a href="#示例1" class="headerlink" title="示例1"></a>示例1</h2><figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">输入：{1,2,3}</span><br><span class="line">返回值：[3,2,1]</span><br></pre></td></tr></tbody></table></figure>

<h2 id="示例2"><a href="#示例2" class="headerlink" title="示例2"></a>示例2</h2><figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">输入：{67,0,24,58}</span><br><span class="line">返回值：[58,24,0,67]</span><br></pre></td></tr></tbody></table></figure>

<h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><h3 id="暴力"><a href="#暴力" class="headerlink" title="暴力"></a>暴力</h3><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">*    public class ListNode {</span></span><br><span class="line"><span class="comment">*        int val;</span></span><br><span class="line"><span class="comment">*        ListNode next = null;</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">*        ListNode(int val) {</span></span><br><span class="line"><span class="comment">*            this.val = val;</span></span><br><span class="line"><span class="comment">*        }</span></span><br><span class="line"><span class="comment">*    }</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Collections;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ArrayList&lt;Integer&gt; <span class="title">printListFromTailToHead</span><span class="params">(ListNode listNode)</span> </span>{</span><br><span class="line">        </span><br><span class="line">        ArrayList&lt;Integer&gt; arrayList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> (listNode!=<span class="keyword">null</span>){</span><br><span class="line">            arrayList.add(listNode.val);</span><br><span class="line">            listNode = listNode.next;</span><br><span class="line">        }</span><br><span class="line">        </span><br><span class="line">        Collections.reverse(arrayList);        </span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> arrayList;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<br>

<h3 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h3><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// 递归</span></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ArrayList&lt;Integer&gt; <span class="title">printListFromTailToHead</span><span class="params">(ListNode listNode)</span> </span>{</span><br><span class="line">        ArrayList&lt;Integer&gt; arrayList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (listNode == <span class="keyword">null</span>) <span class="keyword">return</span> arrayList;</span><br><span class="line">        arrayList = printListFromTailToHead(listNode.next);</span><br><span class="line">        arrayList.add(listNode.val);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> arrayList;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<br>

<h3 id="反转链表"><a href="#反转链表" class="headerlink" title="反转链表"></a>反转链表</h3><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// 反转链表</span></span><br></pre></td></tr></tbody></table></figure>

<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>剑指OFFER</tag>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title>Java 集合（一）</title>
    <url>/post/38cefa6b.html</url>
    <content><![CDATA[<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
  </entry>
  <entry>
    <title>Java集合（五）</title>
    <url>/post/de6e0210.html</url>
    <content><![CDATA[<h1 id="Collections"><a href="#Collections" class="headerlink" title="Collections"></a>Collections</h1><hr>
<p>Collections是一个可以操作Set、List、Map的工具类，对集合对象实现<strong>同步控制</strong>等方法。</p>
<p><strong>把数组转换为集合</strong></p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">addAll</span><span class="params">(Collection c, T[])</span></span></span><br></pre></td></tr></tbody></table></figure>

<a id="more"></a>

<p><strong>排序操作</strong></p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">reverse</span><span class="params">(List list)</span></span>;</span><br><span class="line"><span class="comment">//反转列表元素</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">shuffle</span><span class="params">(List list)</span></span>;</span><br><span class="line"><span class="comment">//list元素随机排序</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(List list)</span></span>;</span><br><span class="line"><span class="comment">//排序</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(List list, Comprator c)</span></span>;</span><br><span class="line"><span class="comment">//用c的规则对list排序</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(List list, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span>;</span><br><span class="line"><span class="comment">//交换list中下标为i、j的元素</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">rotate</span><span class="params">(List list, <span class="keyword">int</span> distance)</span></span>;</span><br><span class="line"><span class="comment">//将list的后distance个元素整体移动到前边，distance可以为负</span></span><br></pre></td></tr></tbody></table></figure>

<p><strong>查找替换</strong></p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">binarySearch</span><span class="params">(List list, Object key)</span></span>;</span><br><span class="line"><span class="comment">//查找key所在位置，前提是list已经有序</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> Object <span class="title">max</span><span class="params">(Collection c)</span></span>;</span><br><span class="line"><span class="comment">//找出c中最大元素， 类似的有 static Object min(Collection c);</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> Object <span class="title">max</span><span class="params">(Collection c, Comparator cmp)</span></span>;</span><br><span class="line"><span class="comment">//使用cmp进行比较找出最大元素， 类似有 static Object min(Collection c, Comparator cmp);</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">fill</span><span class="params">(List list, <span class="keyword">int</span> i)</span></span>;</span><br><span class="line"><span class="comment">//用i填充list</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">indexOfSubList</span><span class="params">(List sourse, List target)</span></span>;</span><br><span class="line"><span class="comment">//返回子list在父list中的索引</span></span><br></pre></td></tr></tbody></table></figure>

<p>下面是搜索子list的函数源码，</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">indexOfSubList</span><span class="params">(List&lt;?&gt; source, List&lt;?&gt; target)</span> </span>{</span><br><span class="line">    <span class="keyword">int</span> sourceSize = source.size();</span><br><span class="line">    <span class="keyword">int</span> targetSize = target.size();</span><br><span class="line">    <span class="keyword">int</span> maxCandidate = sourceSize - targetSize;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (sourceSize &lt; INDEXOFSUBLIST_THRESHOLD ||</span><br><span class="line">        (source <span class="keyword">instanceof</span> RandomAccess&amp;&amp;target <span class="keyword">instanceof</span> RandomAccess)) {</span><br><span class="line">    nextCand:</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> candidate = <span class="number">0</span>; candidate &lt;= maxCandidate; candidate++) {</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>, j=candidate; i&lt;targetSize; i++, j++)</span><br><span class="line">                <span class="keyword">if</span> (!eq(target.get(i), source.get(j)))</span><br><span class="line">                    <span class="keyword">continue</span> nextCand;  <span class="comment">// Element mismatch, try next cand</span></span><br><span class="line">            <span class="keyword">return</span> candidate;  <span class="comment">// All elements of candidate matched target</span></span><br><span class="line">        }</span><br><span class="line">    } <span class="keyword">else</span> {  <span class="comment">// Iterator version of above algorithm</span></span><br><span class="line">        ListIterator&lt;?&gt; si = source.listIterator();</span><br><span class="line">    nextCand:</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> candidate = <span class="number">0</span>; candidate &lt;= maxCandidate; candidate++) {</span><br><span class="line">            ListIterator&lt;?&gt; ti = target.listIterator();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;targetSize; i++) {</span><br><span class="line">                <span class="keyword">if</span> (!eq(ti.next(), si.next())) {</span><br><span class="line">                    <span class="comment">// Back up source iterator to next candidate</span></span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;i; j++)</span><br><span class="line">                        si.previous();</span><br><span class="line">                    <span class="keyword">continue</span> nextCand;</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">return</span> candidate;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;  <span class="comment">// No candidate matched the target</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>该函数使用暴力法求解的。source长度 - target长度就是maxCandidate，就是说，如果source中前maxCandidate个元素都没有匹配到target那么maxCandidate + 1及以后所有元素都没必要尝试匹配了，因为后面的长度已经小于target长度了。</p>
<p>然后有i、j两个标记元素，candidate作为起始 i 遍历source的起始下标，j 作为target的下标，他俩进行比对是否相等，如果不相等，candidate++，就是将source的其实下标向后移动以为，然后 j 重新指向target头部开始匹配；如果相等，i++ , j++，判断下一个字符是否相等，直到 j = target的长度，这时候return cnadidate就是字串所在下。如果一致没有匹配到，return -1表明不存在。</p>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>JZ43 左旋转字符串</title>
    <url>/post/5f4eb573.html</url>
    <content><![CDATA[<p><a href="https://www.nowcoder.com/practice/12d959b108cb42b1ab72cef4d36af5ec?tpId=13&amp;tqId=11196&amp;tPage=1&amp;rp=1&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking&amp;from=cyc_github" target="_blank" rel="noopener">原题链接</a></p>
<h2 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h2><hr>
<p>汇编语言中有一种移位指令叫做循环左移（ROL），现在有个简单的任务，就是用字符串模拟这个指令的运算结果。对于一个给定的字符序列 S，请你把其循环左移 K 位后的序列输出（保证 K 小于等于 S 的长度）。例如，字符序列S=”abcXYZdef”,要求输出循环左移 3 位后的结果，即“XYZdefabc”。是不是很简单？OK，搞定它！<a id="more"></a></p>
<br>

<h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">输入："abcXYZdef",3</span><br><span class="line">返回值："XYZdefabc"</span><br></pre></td></tr></tbody></table></figure>

<br>

<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>又是偷懒了直接用了String(char[], int, int)的构造方法，然后return两个String相加即可。</p>
<p>然后，还是有这哥的双指针解法，<a href="https://github.com/CyC2018/CS-Notes/blob/master/notes/58.2%20%E5%B7%A6%E6%97%8B%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2.md" target="_blank" rel="noopener">点击查看</a>，顺着这个思路又写了解二。</p>
<h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>{</span><br><span class="line">    <span class="comment">//假设输入n是小于str.length()的</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">LeftRotateString</span><span class="params">(String str,<span class="keyword">int</span> n)</span> </span>{</span><br><span class="line">        <span class="keyword">int</span> len = str.length();</span><br><span class="line">        <span class="keyword">if</span> (len==<span class="number">0</span>) <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">        <span class="keyword">if</span> (n &gt;=len) <span class="keyword">return</span> str;</span><br><span class="line">        <span class="keyword">char</span>[] chars = str.toCharArray();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> String(chars, n, len-n ) + <span class="keyword">new</span> String(chars, <span class="number">0</span>, n);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h3 id="解二"><a href="#解二" class="headerlink" title="解二"></a>解二</h3><p>”abcXYZdef“转成”XYZdefabc”，就是在数组中把abc逆序，XYZdef逆序，然后整体逆序输出为字符串，</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">LeftRotateString</span><span class="params">(String str,<span class="keyword">int</span> n)</span> </span>{</span><br><span class="line">        <span class="keyword">int</span> len = str.length();</span><br><span class="line">        <span class="keyword">if</span> (len==<span class="number">0</span>) <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">        <span class="keyword">if</span> (n &gt;=len|| n&lt;<span class="number">0</span>) <span class="keyword">return</span> str;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">char</span>[] chars = str.toCharArray();</span><br><span class="line"></span><br><span class="line">        reverse(chars, <span class="number">0</span>, n-<span class="number">1</span>);</span><br><span class="line">        reverse(chars, n, len-<span class="number">1</span>);</span><br><span class="line">        reverse(chars, <span class="number">0</span>, len -<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> String(chars);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">reverse</span><span class="params">(<span class="keyword">char</span>[] chars, <span class="keyword">int</span> from, <span class="keyword">int</span> to)</span></span>{</span><br><span class="line">        <span class="keyword">while</span> (from&lt; to){</span><br><span class="line">            swap(chars, from++, to--);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">char</span>[] chars, <span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>{</span><br><span class="line">        <span class="keyword">char</span> tmp =chars[a];</span><br><span class="line">        chars[a] = chars[b];</span><br><span class="line">        chars[b] = tmp;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>剑指OFFER</tag>
        <tag>数组</tag>
      </tags>
  </entry>
</search>
